# é«˜çº§ç³»ç»Ÿæ¶æ„è®¾è®¡

> ä»å•ä½“æ€ç»´åˆ°åˆ†å¸ƒå¼ç³»ç»Ÿæ¶æ„å¸ˆçš„è¿›é˜¶æŒ‡å—

## ğŸ“š ç›®å½•

- [åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ç†è®º](#åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ç†è®º)
- [å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™](#å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™)
- [é«˜å¯ç”¨æ€§æ¶æ„è®¾è®¡](#é«˜å¯ç”¨æ€§æ¶æ„è®¾è®¡)
- [æ•°æ®æ¶æ„è®¾è®¡](#æ•°æ®æ¶æ„è®¾è®¡)
- [æ€§èƒ½æ¶æ„ä¼˜åŒ–](#æ€§èƒ½æ¶æ„ä¼˜åŒ–)
- [å®è·µç¯å¢ƒæ­å»º](#å®è·µç¯å¢ƒæ­å»º)
- [æ¶æ„è®¾è®¡å®æˆ˜](#æ¶æ„è®¾è®¡å®æˆ˜)

---

## åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ç†è®º

### ğŸ¯ **CAPå®šç†ä¸BASEç†è®º**

#### CAPå®šç†æ ¸å¿ƒæ¦‚å¿µ
```
ä¸€è‡´æ€§ (Consistency)    - æ‰€æœ‰èŠ‚ç‚¹åŒä¸€æ—¶é—´çœ‹åˆ°ç›¸åŒæ•°æ®
å¯ç”¨æ€§ (Availability)   - ç³»ç»ŸæŒç»­å¯ç”¨ï¼Œå³ä½¿éƒ¨åˆ†èŠ‚ç‚¹æ•…éšœ
åˆ†åŒºå®¹é”™ (Partition)     - ç½‘ç»œåˆ†åŒºæ—¶ç³»ç»Ÿç»§ç»­è¿è¡Œ
```

**CAPä¸å¯èƒ½ä¸‰è§’**:
- **CAç³»ç»Ÿ**: ä¼ ç»Ÿå•ä½“æ•°æ®åº“ (MySQL, PostgreSQL)
- **CPç³»ç»Ÿ**: åˆ†å¸ƒå¼æ•°æ®åº“ (MongoDB, HBase)
- **APç³»ç»Ÿ**: ç¼“å­˜ç³»ç»Ÿ (Redis Cluster, Cassandra)

#### BASEç†è®ºå®è·µ
```bash
# BASE = Basically Available + Soft State + Eventually Consistent

# åŸºæœ¬å¯ç”¨ (Basically Available)
# ç³»ç»Ÿå…è®¸æŸå¤±éƒ¨åˆ†å¯ç”¨æ€§æ¥ä¿è¯æ ¸å¿ƒåŠŸèƒ½

# è½¯çŠ¶æ€ (Soft State)  
# ç³»ç»ŸçŠ¶æ€å¯ä»¥æœ‰ä¸€å®šæ—¶é—´çš„å»¶è¿Ÿ

# æœ€ç»ˆä¸€è‡´æ€§ (Eventually Consistent)
# ç³»ç»Ÿä¿è¯æœ€ç»ˆæ‰€æœ‰å‰¯æœ¬è¾¾åˆ°ä¸€è‡´çŠ¶æ€
```

#### åˆ†å¸ƒå¼ç³»ç»ŸæŒ‘æˆ˜

**ç½‘ç»œåˆ†åŒº**:
```bash
# ç½‘ç»œåˆ†åŒºæ¨¡æ‹Ÿ
# ä½¿ç”¨iptablesæ¨¡æ‹Ÿç½‘ç»œåˆ†åŒº
sudo iptables -A INPUT -s 192.168.1.10 -j DROP
sudo iptables -A OUTPUT -d 192.168.1.10 -j DROP

# è§‚å¯Ÿç³»ç»Ÿè¡Œä¸º
curl -v http://api.service.com/health
```

**æ—¶é’ŸåŒæ­¥**:
```bash
# NTPæ—¶é—´åŒæ­¥é…ç½®
sudo apt install ntp
sudo systemctl enable ntp

# éªŒè¯æ—¶é’ŸåŒæ­¥
ntpq -p
chrony sources -v
```

### ğŸ”„ **åˆ†å¸ƒå¼ä¸€è‡´æ€§ç®—æ³•**

#### Raftç®—æ³•å®ç°
```go
// RaftèŠ‚ç‚¹çŠ¶æ€
type NodeState int
const (
    Follower NodeState = iota
    Candidate
    Leader
)

// RaftèŠ‚ç‚¹ç»“æ„
type RaftNode struct {
    ID          int
    State       NodeState
    CurrentTerm int
    VotedFor    int
    Log         []LogEntry
    CommitIndex int
    LastApplied int
}

// é€‰ä¸¾è¶…æ—¶
func (n *RaftNode) StartElection() {
    n.CurrentTerm++
    n.State = Candidate
    n.VotedFor = n.ID
    
    // å‘é€æŠ•ç¥¨è¯·æ±‚
    votes := 1
    for _, peer := range n.peers {
        if peer.RequestVote(n.CurrentTerm, n.ID) {
            votes++
        }
    }
    
    // è·å¾—å¤šæ•°ç¥¨æˆä¸ºLeader
    if votes > len(n.peers)/2 {
        n.State = Leader
        n.sendHeartbeats()
    }
}
```

#### ä½¿ç”¨etcdå®ç°åˆ†å¸ƒå¼é”
```bash
# å®‰è£…etcd
curl -L https://github.com/etcd-io/etcd/releases/download/v3.5.0/etcd-v3.5.0-linux-amd64.tar.gz -o etcd.tar.gz
tar xzf etcd.tar.gz
sudo mv etcd-v3.5.0-linux-amd64/etcd* /usr/local/bin/

# å¯åŠ¨etcdé›†ç¾¤
etcd --name node1 --data-dir /var/lib/etcd/node1 \
  --listen-client-urls http://0.0.0.0:2379 \
  --advertise-client-urls http://192.168.1.10:2379 \
  --listen-peer-urls http://0.0.0.0:2380 \
  --initial-advertise-peer-urls http://192.168.1.10:2380 \
  --initial-cluster node1=http://192.168.1.10:2380,node2=http://192.168.1.11:2380,node3=http://192.168.1.12:2380
```

```go
// Goå®¢æˆ·ç«¯åˆ†å¸ƒå¼é”å®ç°
package main

import (
    "context"
    "time"
    "go.etcd.io/etcd/clientv3"
    "go.etcd.io/etcd/clientv3/concurrency"
)

func acquireDistributedLock() {
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   []string{"192.168.1.10:2379"},
        DialTimeout: 5 * time.Second,
    })
    
    // åˆ›å»ºä¼šè¯
    session, err := concurrency.NewSession(client)
    defer session.Close()
    
    // åˆ›å»ºäº’æ–¥é”
    mutex := concurrency.NewMutex(session, "/distributed-lock/")
    
    // è·å–é”
    ctx := context.Background()
    if err := mutex.Lock(ctx); err != nil {
        panic(err)
    }
    
    // æ‰§è¡Œä¸´ç•ŒåŒºä»£ç 
    performCriticalSection()
    
    // é‡Šæ”¾é”
    mutex.Unlock(ctx)
}
```

---

## å¾®æœåŠ¡æ¶æ„è®¾è®¡åŸåˆ™

### ğŸ—ï¸ **å¾®æœåŠ¡æ‹†åˆ†ç­–ç•¥**

#### åŸŸé©±åŠ¨è®¾è®¡ (DDD) æ‹†åˆ†
```
# ç”µå•†ç³»ç»ŸæœåŠ¡æ‹†åˆ†ç¤ºä¾‹

ç”¨æˆ·åŸŸ (User Domain)
â”œâ”€â”€ ç”¨æˆ·æœåŠ¡ (User Service)
â”œâ”€â”€ è®¤è¯æœåŠ¡ (Auth Service)
â””â”€â”€ ç”¨æˆ·ç”»åƒæœåŠ¡ (Profile Service)

å•†å“åŸŸ (Product Domain)
â”œâ”€â”€ å•†å“æœåŠ¡ (Product Service) 
â”œâ”€â”€ åº“å­˜æœåŠ¡ (Inventory Service)
â””â”€â”€ ç±»ç›®æœåŠ¡ (Category Service)

è®¢å•åŸŸ (Order Domain)
â”œâ”€â”€ è®¢å•æœåŠ¡ (Order Service)
â”œâ”€â”€ æ”¯ä»˜æœåŠ¡ (Payment Service)
â””â”€â”€ ç‰©æµæœåŠ¡ (Shipping Service)
```

#### æœåŠ¡è¾¹ç•Œå®šä¹‰
```yaml
# ç”¨æˆ·æœåŠ¡è¾¹ç•Œå®šä¹‰
apiVersion: v1
kind: Service
metadata:
  name: user-service
  annotations:
    service.boundary/domain: "user"
    service.boundary/data-ownership: "user_profile,user_preferences"
    service.boundary/external-apis: "GET /users, POST /users, PUT /users/{id}"
spec:
  selector:
    app: user-service
  ports:
  - port: 8080
    targetPort: 8080
---
# æœåŠ¡æ¥å£å¥‘çº¦
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-service-contract
data:
  openapi.yaml: |
    openapi: 3.0.0
    info:
      title: User Service API
      version: 1.0.0
    paths:
      /users:
        get:
          summary: Get users
          responses:
            '200':
              description: Successful response
        post:
          summary: Create user
          requestBody:
            required: true
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/User'
```

### ğŸŒ **æœåŠ¡é—´é€šä¿¡è®¾è®¡**

#### åŒæ­¥é€šä¿¡ (HTTP/gRPC)
```proto
// user.proto - gRPCæœåŠ¡å®šä¹‰
syntax = "proto3";

package user;

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
}

message User {
  int64 id = 1;
  string email = 2;
  string name = 3;
  int64 created_at = 4;
}

message GetUserRequest {
  int64 user_id = 1;
}

message GetUserResponse {
  User user = 1;
}
```

```go
// gRPCæœåŠ¡å®ç°
package main

import (
    "context"
    "net"
    "google.golang.org/grpc"
    pb "github.com/company/user-service/proto"
)

type userServiceServer struct {
    pb.UnimplementedUserServiceServer
    userRepo UserRepository
}

func (s *userServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    user, err := s.userRepo.GetUser(req.UserId)
    if err != nil {
        return nil, err
    }
    
    return &pb.GetUserResponse{
        User: &pb.User{
            Id:        user.ID,
            Email:     user.Email,
            Name:      user.Name,
            CreatedAt: user.CreatedAt.Unix(),
        },
    }, nil
}

func main() {
    lis, err := net.Listen("tcp", ":8080")
    if err != nil {
        panic(err)
    }
    
    server := grpc.NewServer()
    pb.RegisterUserServiceServer(server, &userServiceServer{
        userRepo: NewUserRepository(),
    })
    
    server.Serve(lis)
}
```

#### å¼‚æ­¥é€šä¿¡ (æ¶ˆæ¯é˜Ÿåˆ—)
```yaml
# Kafkaé…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: kafka-config
data:
  server.properties: |
    broker.id=1
    listeners=PLAINTEXT://0.0.0.0:9092
    advertised.listeners=PLAINTEXT://kafka:9092
    num.network.threads=3
    num.io.threads=8
    socket.send.buffer.bytes=102400
    socket.receive.buffer.bytes=102400
    socket.request.max.bytes=104857600
    log.dirs=/var/lib/kafka/logs
    num.partitions=3
    num.recovery.threads.per.data.dir=1
    offsets.topic.replication.factor=1
    transaction.state.log.replication.factor=1
    transaction.state.log.min.isr=1
    log.retention.hours=168
    log.segment.bytes=1073741824
    log.retention.check.interval.ms=300000
    zookeeper.connect=zookeeper:2181
    zookeeper.connection.timeout.ms=18000
    group.initial.rebalance.delay.ms=0
```

```go
// äº‹ä»¶å‘å¸ƒè®¢é˜…æ¨¡å¼
package main

import (
    "encoding/json"
    "github.com/Shopify/sarama"
)

// ç”¨æˆ·åˆ›å»ºäº‹ä»¶
type UserCreatedEvent struct {
    UserID    int64  `json:"user_id"`
    Email     string `json:"email"`
    Name      string `json:"name"`
    Timestamp int64  `json:"timestamp"`
}

// äº‹ä»¶å‘å¸ƒè€…
type EventPublisher struct {
    producer sarama.SyncProducer
}

func (p *EventPublisher) PublishUserCreated(event UserCreatedEvent) error {
    data, err := json.Marshal(event)
    if err != nil {
        return err
    }
    
    msg := &sarama.ProducerMessage{
        Topic: "user.created",
        Value: sarama.StringEncoder(data),
    }
    
    _, _, err = p.producer.SendMessage(msg)
    return err
}

// äº‹ä»¶æ¶ˆè´¹è€…
type EventConsumer struct {
    consumer sarama.Consumer
}

func (c *EventConsumer) ConsumeUserCreated() {
    partitionConsumer, err := c.consumer.ConsumePartition("user.created", 0, sarama.OffsetNewest)
    if err != nil {
        panic(err)
    }
    
    for message := range partitionConsumer.Messages() {
        var event UserCreatedEvent
        if err := json.Unmarshal(message.Value, &event); err != nil {
            continue
        }
        
        // å¤„ç†ç”¨æˆ·åˆ›å»ºäº‹ä»¶
        handleUserCreated(event)
    }
}
```

### ğŸ›¡ï¸ **å¾®æœåŠ¡æ²»ç†**

#### APIç½‘å…³é…ç½®
```yaml
# Kong APIç½‘å…³é…ç½®
apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: rate-limiting
config:
  minute: 100
  hour: 1000
plugin: rate-limiting
---
apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: jwt-auth
plugin: jwt
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway
  annotations:
    kubernetes.io/ingress.class: kong
    konghq.com/plugins: rate-limiting,jwt-auth
spec:
  rules:
  - host: api.company.com
    http:
      paths:
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 8080
      - path: /products
        pathType: Prefix
        backend:
          service:
            name: product-service
            port:
              number: 8080
```

#### æœåŠ¡å‘ç°é…ç½®
```yaml
# ConsulæœåŠ¡å‘ç°
apiVersion: apps/v1
kind: Deployment
metadata:
  name: consul
spec:
  replicas: 3
  selector:
    matchLabels:
      app: consul
  template:
    metadata:
      labels:
        app: consul
    spec:
      containers:
      - name: consul
        image: consul:1.15.2
        ports:
        - containerPort: 8500
        - containerPort: 8600
        env:
        - name: CONSUL_LOCAL_CONFIG
          value: |
            {
              "datacenter": "dc1",
              "data_dir": "/consul/data",
              "log_level": "INFO",
              "server": true,
              "bootstrap_expect": 3,
              "bind_addr": "0.0.0.0",
              "client_addr": "0.0.0.0",
              "retry_join": ["consul-0.consul", "consul-1.consul", "consul-2.consul"],
              "ui_config": {
                "enabled": true
              },
              "connect": {
                "enabled": true
              }
            }
        volumeMounts:
        - name: consul-data
          mountPath: /consul/data
      volumes:
      - name: consul-data
        emptyDir: {}
```

---

## é«˜å¯ç”¨æ€§æ¶æ„è®¾è®¡

### âš¡ **å®¹é”™è®¾è®¡æ¨¡å¼**

#### ç†”æ–­å™¨æ¨¡å¼
```go
// ç†”æ–­å™¨å®ç°
package main

import (
    "errors"
    "sync"
    "time"
)

type CircuitBreakerState int

const (
    Closed CircuitBreakerState = iota
    Open
    HalfOpen
)

type CircuitBreaker struct {
    mutex           sync.Mutex
    state           CircuitBreakerState
    failureCount    int
    successCount    int
    failureThreshold int
    timeout         time.Duration
    lastFailureTime time.Time
}

func NewCircuitBreaker(failureThreshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        state:           Closed,
        failureThreshold: failureThreshold,
        timeout:         timeout,
    }
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    if cb.state == Open {
        if time.Since(cb.lastFailureTime) > cb.timeout {
            cb.state = HalfOpen
            cb.failureCount = 0
        } else {
            return errors.New("circuit breaker is open")
        }
    }
    
    err := fn()
    
    if err != nil {
        cb.onFailure()
        return err
    }
    
    cb.onSuccess()
    return nil
}

func (cb *CircuitBreaker) onFailure() {
    cb.failureCount++
    cb.lastFailureTime = time.Now()
    
    if cb.failureCount >= cb.failureThreshold {
        cb.state = Open
    }
}

func (cb *CircuitBreaker) onSuccess() {
    cb.failureCount = 0
    cb.successCount++
    
    if cb.state == HalfOpen {
        cb.state = Closed
    }
}
```

#### é‡è¯•æœºåˆ¶
```go
// æŒ‡æ•°é€€é¿é‡è¯•
package main

import (
    "context"
    "math"
    "time"
)

type RetryConfig struct {
    MaxRetries    int
    InitialDelay  time.Duration
    MaxDelay      time.Duration
    Multiplier    float64
    Jitter        bool
}

func ExponentialBackoffRetry(ctx context.Context, config RetryConfig, fn func() error) error {
    var lastErr error
    delay := config.InitialDelay
    
    for attempt := 0; attempt <= config.MaxRetries; attempt++ {
        if attempt > 0 {
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-time.After(delay):
            }
        }
        
        if err := fn(); err == nil {
            return nil
        } else {
            lastErr = err
        }
        
        // è®¡ç®—ä¸‹æ¬¡é‡è¯•å»¶è¿Ÿ
        delay = time.Duration(float64(delay) * config.Multiplier)
        if delay > config.MaxDelay {
            delay = config.MaxDelay
        }
        
        // æ·»åŠ æŠ–åŠ¨
        if config.Jitter {
            jitter := time.Duration(math.Rand() * float64(delay) * 0.1)
            delay += jitter
        }
    }
    
    return lastErr
}

// ä½¿ç”¨ç¤ºä¾‹
func callExternalService() error {
    config := RetryConfig{
        MaxRetries:   3,
        InitialDelay: 100 * time.Millisecond,
        MaxDelay:     5 * time.Second,
        Multiplier:   2.0,
        Jitter:       true,
    }
    
    return ExponentialBackoffRetry(context.Background(), config, func() error {
        // è°ƒç”¨å¤–éƒ¨æœåŠ¡
        return httpClient.Get("https://api.external.com/data")
    })
}
```

### ğŸ”„ **è´Ÿè½½å‡è¡¡ç­–ç•¥**

#### å¤šçº§è´Ÿè½½å‡è¡¡
```yaml
# Nginxè´Ÿè½½å‡è¡¡é…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    upstream backend {
        # æƒé‡è½®è¯¢
        server backend1.example.com:8080 weight=3;
        server backend2.example.com:8080 weight=2;
        server backend3.example.com:8080 weight=1;
        
        # å¥åº·æ£€æŸ¥
        keepalive 32;
        keepalive_requests 100;
        keepalive_timeout 60s;
    }
    
    upstream backend_backup {
        server backup1.example.com:8080;
        server backup2.example.com:8080;
    }
    
    server {
        listen 80;
        server_name api.example.com;
        
        location / {
            proxy_pass http://backend;
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
            proxy_next_upstream_tries 3;
            proxy_next_upstream_timeout 10s;
            
            # æ•…éšœè½¬ç§»åˆ°å¤‡ç”¨æœåŠ¡å™¨
            error_page 500 502 503 504 @backup;
        }
        
        location @backup {
            internal;
            proxy_pass http://backend_backup;
        }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-lb
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-lb
  template:
    metadata:
      labels:
        app: nginx-lb
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-config
```

#### Kubernetes HPAé…ç½®
```yaml
# æ°´å¹³Podè‡ªåŠ¨æ‰©ç¼©å®¹
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend-service
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: custom_requests_per_second
      target:
        type: AverageValue
        averageValue: "100"
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 4
        periodSeconds: 15
      selectPolicy: Max
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
```

### ğŸ¥ **å¥åº·æ£€æŸ¥ä¸ç›‘æ§**

#### å¤šç»´åº¦å¥åº·æ£€æŸ¥
```go
// å¥åº·æ£€æŸ¥æœåŠ¡
package main

import (
    "context"
    "encoding/json"
    "net/http"
    "time"
)

type HealthStatus string

const (
    Healthy   HealthStatus = "healthy"
    Unhealthy HealthStatus = "unhealthy"
    Degraded  HealthStatus = "degraded"
)

type HealthCheck struct {
    Name   string       `json:"name"`
    Status HealthStatus `json:"status"`
    Error  string       `json:"error,omitempty"`
}

type HealthResponse struct {
    Status    HealthStatus  `json:"status"`
    Checks    []HealthCheck `json:"checks"`
    Timestamp time.Time     `json:"timestamp"`
}

type HealthChecker interface {
    Check(ctx context.Context) HealthCheck
}

// æ•°æ®åº“å¥åº·æ£€æŸ¥
type DatabaseHealthChecker struct {
    db Database
}

func (d *DatabaseHealthChecker) Check(ctx context.Context) HealthCheck {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    if err := d.db.Ping(ctx); err != nil {
        return HealthCheck{
            Name:   "database",
            Status: Unhealthy,
            Error:  err.Error(),
        }
    }
    
    return HealthCheck{
        Name:   "database",
        Status: Healthy,
    }
}

// å¤–éƒ¨æœåŠ¡å¥åº·æ£€æŸ¥
type ExternalServiceHealthChecker struct {
    client  *http.Client
    url     string
    timeout time.Duration
}

func (e *ExternalServiceHealthChecker) Check(ctx context.Context) HealthCheck {
    ctx, cancel := context.WithTimeout(ctx, e.timeout)
    defer cancel()
    
    req, err := http.NewRequestWithContext(ctx, "GET", e.url+"/health", nil)
    if err != nil {
        return HealthCheck{
            Name:   "external_service",
            Status: Unhealthy,
            Error:  err.Error(),
        }
    }
    
    resp, err := e.client.Do(req)
    if err != nil {
        return HealthCheck{
            Name:   "external_service",
            Status: Unhealthy,
            Error:  err.Error(),
        }
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return HealthCheck{
            Name:   "external_service",
            Status: Degraded,
            Error:  "service returning non-200 status",
        }
    }
    
    return HealthCheck{
        Name:   "external_service",
        Status: Healthy,
    }
}

// å¥åº·æ£€æŸ¥èšåˆå™¨
type HealthService struct {
    checkers []HealthChecker
}

func (h *HealthService) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
    defer cancel()
    
    checks := make([]HealthCheck, len(h.checkers))
    overallStatus := Healthy
    
    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å¥åº·æ£€æŸ¥
    checkChan := make(chan struct {
        index int
        check HealthCheck
    }, len(h.checkers))
    
    for i, checker := range h.checkers {
        go func(index int, checker HealthChecker) {
            check := checker.Check(ctx)
            checkChan <- struct {
                index int
                check HealthCheck
            }{index, check}
        }(i, checker)
    }
    
    // æ”¶é›†æ£€æŸ¥ç»“æœ
    for i := 0; i < len(h.checkers); i++ {
        result := <-checkChan
        checks[result.index] = result.check
        
        if result.check.Status == Unhealthy {
            overallStatus = Unhealthy
        } else if result.check.Status == Degraded && overallStatus == Healthy {
            overallStatus = Degraded
        }
    }
    
    response := HealthResponse{
        Status:    overallStatus,
        Checks:    checks,
        Timestamp: time.Now(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    if overallStatus == Unhealthy {
        w.WriteHeader(http.StatusServiceUnavailable)
    } else if overallStatus == Degraded {
        w.WriteHeader(http.StatusPartialContent)
    }
    
    json.NewEncoder(w).Encode(response)
}
```

---

## æ•°æ®æ¶æ„è®¾è®¡

### ğŸ“Š **æ•°æ®å­˜å‚¨ç­–ç•¥**

#### è¯»å†™åˆ†ç¦»æ¶æ„
```yaml
# MySQLä¸»ä»å¤åˆ¶é…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-master-config
data:
  my.cnf: |
    [mysqld]
    server-id = 1
    log-bin = mysql-bin
    binlog-format = ROW
    gtid-mode = ON
    enforce-gtid-consistency = ON
    log-slave-updates = ON
    read-only = OFF
    
    # æ€§èƒ½ä¼˜åŒ–
    innodb_buffer_pool_size = 2G
    innodb_log_file_size = 256M
    innodb_flush_log_at_trx_commit = 2
    sync_binlog = 0
    
    # è¿æ¥ä¼˜åŒ–
    max_connections = 1000
    max_connect_errors = 100000
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-slave-config
data:
  my.cnf: |
    [mysqld]
    server-id = 2
    log-bin = mysql-bin
    binlog-format = ROW
    gtid-mode = ON
    enforce-gtid-consistency = ON
    log-slave-updates = ON
    read-only = ON
    slave-skip-errors = 1062,1053,1146
    
    # åªè¯»ä¼˜åŒ–
    innodb_buffer_pool_size = 4G
    query_cache_size = 512M
    query_cache_type = 1
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-master
spec:
  serviceName: mysql-master
  replicas: 1
  selector:
    matchLabels:
      app: mysql-master
  template:
    metadata:
      labels:
        app: mysql-master
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: root-password
        volumeMounts:
        - name: mysql-config
          mountPath: /etc/mysql/conf.d
        - name: mysql-data
          mountPath: /var/lib/mysql
      volumes:
      - name: mysql-config
        configMap:
          name: mysql-master-config
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 100Gi
```

#### æ•°æ®åˆ†ç‰‡ç­–ç•¥
```go
// æ•°æ®åˆ†ç‰‡è·¯ç”±å™¨
package main

import (
    "crypto/md5"
    "fmt"
    "hash/crc32"
)

type ShardingStrategy interface {
    GetShard(key string) int
}

// ä¸€è‡´æ€§å“ˆå¸Œåˆ†ç‰‡
type ConsistentHashSharding struct {
    shardCount int
    ring       map[uint32]int
}

func NewConsistentHashSharding(shardCount int) *ConsistentHashSharding {
    ring := make(map[uint32]int)
    
    // ä¸ºæ¯ä¸ªåˆ†ç‰‡åˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹
    for i := 0; i < shardCount; i++ {
        for j := 0; j < 100; j++ {
            virtualKey := fmt.Sprintf("shard_%d_virtual_%d", i, j)
            hash := crc32.ChecksumIEEE([]byte(virtualKey))
            ring[hash] = i
        }
    }
    
    return &ConsistentHashSharding{
        shardCount: shardCount,
        ring:       ring,
    }
}

func (c *ConsistentHashSharding) GetShard(key string) int {
    hash := crc32.ChecksumIEEE([]byte(key))
    
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhashå€¼çš„è™šæ‹ŸèŠ‚ç‚¹
    for virtualHash, shard := range c.ring {
        if virtualHash >= hash {
            return shard
        }
    }
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›ç¬¬ä¸€ä¸ªåˆ†ç‰‡
    return 0
}

// èŒƒå›´åˆ†ç‰‡
type RangeSharding struct {
    ranges []ShardRange
}

type ShardRange struct {
    Min   interface{}
    Max   interface{}
    Shard int
}

func (r *RangeSharding) GetShard(key string) int {
    // æ ¹æ®keyçš„èŒƒå›´ç¡®å®šåˆ†ç‰‡
    for _, shardRange := range r.ranges {
        if key >= shardRange.Min.(string) && key <= shardRange.Max.(string) {
            return shardRange.Shard
        }
    }
    return 0
}

// æ•°æ®è®¿é—®å±‚
type ShardedDatabase struct {
    shards   []Database
    strategy ShardingStrategy
}

func (s *ShardedDatabase) Get(key string) (interface{}, error) {
    shardIndex := s.strategy.GetShard(key)
    return s.shards[shardIndex].Get(key)
}

func (s *ShardedDatabase) Set(key string, value interface{}) error {
    shardIndex := s.strategy.GetShard(key)
    return s.shards[shardIndex].Set(key, value)
}

// è·¨åˆ†ç‰‡æŸ¥è¯¢
func (s *ShardedDatabase) MultiShardQuery(query string) ([]interface{}, error) {
    results := make(chan interface{}, len(s.shards))
    errors := make(chan error, len(s.shards))
    
    // å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰åˆ†ç‰‡
    for _, shard := range s.shards {
        go func(db Database) {
            result, err := db.Query(query)
            if err != nil {
                errors <- err
                return
            }
            results <- result
        }(shard)
    }
    
    // æ”¶é›†ç»“æœ
    var allResults []interface{}
    for i := 0; i < len(s.shards); i++ {
        select {
        case result := <-results:
            allResults = append(allResults, result)
        case err := <-errors:
            return nil, err
        }
    }
    
    return allResults, nil
}
```

### ğŸ“ˆ **ç¼“å­˜æ¶æ„è®¾è®¡**

#### å¤šçº§ç¼“å­˜ç­–ç•¥
```yaml
# Redisé›†ç¾¤é…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-config
data:
  redis.conf: |
    # é›†ç¾¤é…ç½®
    cluster-enabled yes
    cluster-config-file nodes.conf
    cluster-node-timeout 15000
    appendonly yes
    
    # å†…å­˜ä¼˜åŒ–
    maxmemory 2gb
    maxmemory-policy allkeys-lru
    
    # æŒä¹…åŒ–
    save 900 1
    save 300 10
    save 60 10000
    
    # ç½‘ç»œä¼˜åŒ–
    tcp-keepalive 300
    timeout 0
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
spec:
  serviceName: redis-cluster
  replicas: 6
  selector:
    matchLabels:
      app: redis-cluster
  template:
    metadata:
      labels:
        app: redis-cluster
    spec:
      containers:
      - name: redis
        image: redis:7.0
        ports:
        - containerPort: 6379
        - containerPort: 16379
        command:
        - redis-server
        - /etc/redis/redis.conf
        volumeMounts:
        - name: redis-config
          mountPath: /etc/redis
        - name: redis-data
          mountPath: /data
      volumes:
      - name: redis-config
        configMap:
          name: redis-config
  volumeClaimTemplates:
  - metadata:
      name: redis-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 50Gi
```

```go
// å¤šçº§ç¼“å­˜å®ç°
package main

import (
    "context"
    "encoding/json"
    "sync"
    "time"
    
    "github.com/go-redis/redis/v8"
    "github.com/patrickmn/go-cache"
)

type CacheLevel int

const (
    L1Cache CacheLevel = iota // å†…å­˜ç¼“å­˜
    L2Cache                   // Redisç¼“å­˜
    L3Cache                   // æ•°æ®åº“
)

type MultiLevelCache struct {
    l1Cache *cache.Cache
    l2Cache *redis.Client
    l3Cache Database
    mutex   sync.RWMutex
}

func NewMultiLevelCache(redisClient *redis.Client, database Database) *MultiLevelCache {
    return &MultiLevelCache{
        l1Cache: cache.New(5*time.Minute, 10*time.Minute),
        l2Cache: redisClient,
        l3Cache: database,
    }
}

func (m *MultiLevelCache) Get(ctx context.Context, key string) (interface{}, error) {
    // L1ç¼“å­˜æŸ¥è¯¢
    if value, found := m.l1Cache.Get(key); found {
        return value, nil
    }
    
    // L2ç¼“å­˜æŸ¥è¯¢
    result, err := m.l2Cache.Get(ctx, key).Result()
    if err == nil {
        var value interface{}
        if err := json.Unmarshal([]byte(result), &value); err == nil {
            // æ›´æ–°L1ç¼“å­˜
            m.l1Cache.Set(key, value, cache.DefaultExpiration)
            return value, nil
        }
    }
    
    // L3æ•°æ®åº“æŸ¥è¯¢
    value, err := m.l3Cache.Get(key)
    if err != nil {
        return nil, err
    }
    
    // æ›´æ–°L2ç¼“å­˜
    data, _ := json.Marshal(value)
    m.l2Cache.Set(ctx, key, data, time.Hour)
    
    // æ›´æ–°L1ç¼“å­˜
    m.l1Cache.Set(key, value, cache.DefaultExpiration)
    
    return value, nil
}

func (m *MultiLevelCache) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
    // æ›´æ–°æ•°æ®åº“
    if err := m.l3Cache.Set(key, value); err != nil {
        return err
    }
    
    // æ›´æ–°L2ç¼“å­˜
    data, _ := json.Marshal(value)
    m.l2Cache.Set(ctx, key, data, ttl)
    
    // æ›´æ–°L1ç¼“å­˜
    m.l1Cache.Set(key, value, ttl)
    
    return nil
}

func (m *MultiLevelCache) Delete(ctx context.Context, key string) error {
    // åˆ é™¤L1ç¼“å­˜
    m.l1Cache.Delete(key)
    
    // åˆ é™¤L2ç¼“å­˜
    m.l2Cache.Del(ctx, key)
    
    // åˆ é™¤æ•°æ®åº“è®°å½•
    return m.l3Cache.Delete(key)
}

// ç¼“å­˜é¢„çƒ­
func (m *MultiLevelCache) Warmup(ctx context.Context, keys []string) error {
    for _, key := range keys {
        go func(k string) {
            m.Get(ctx, k)
        }(key)
    }
    return nil
}
```

---

## æ€§èƒ½æ¶æ„ä¼˜åŒ–

### âš¡ **æ€§èƒ½ç›‘æ§ä½“ç³»**

#### APMé›†æˆé…ç½®
```yaml
# Jaegeråˆ†å¸ƒå¼è¿½è¸ª
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger-all-in-one
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jaeger
  template:
    metadata:
      labels:
        app: jaeger
    spec:
      containers:
      - name: jaeger
        image: jaegertracing/all-in-one:1.45
        ports:
        - containerPort: 16686
        - containerPort: 14268
        - containerPort: 6831
          protocol: UDP
        - containerPort: 6832
          protocol: UDP
        env:
        - name: COLLECTOR_ZIPKIN_HOST_PORT
          value: ":9411"
        - name: SPAN_STORAGE_TYPE
          value: "elasticsearch"
        - name: ES_SERVER_URLS
          value: "http://elasticsearch:9200"
---
apiVersion: v1
kind: Service
metadata:
  name: jaeger-service
spec:
  selector:
    app: jaeger
  ports:
  - name: ui
    port: 16686
    targetPort: 16686
  - name: collector
    port: 14268
    targetPort: 14268
  - name: agent-udp-1
    port: 6831
    targetPort: 6831
    protocol: UDP
  - name: agent-udp-2
    port: 6832
    targetPort: 6832
    protocol: UDP
```

```go
// OpenTelemetryé›†æˆ
package main

import (
    "context"
    "log"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

func initTracer() func() {
    // åˆ›å»ºJaegerå¯¼å‡ºå™¨
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint("http://jaeger:14268/api/traces")))
    if err != nil {
        log.Fatal(err)
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exp),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName("user-service"),
            semconv.ServiceVersion("v1.0.0"),
        )),
    )
    
    otel.SetTracerProvider(tp)
    
    return func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            log.Fatal(err)
        }
    }
}

// ä¸šåŠ¡æ–¹æ³•è¿½è¸ª
func GetUser(ctx context.Context, userID string) (*User, error) {
    tracer := otel.Tracer("user-service")
    ctx, span := tracer.Start(ctx, "GetUser")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.String("operation", "get_user"),
    )
    
    // æ•°æ®åº“æŸ¥è¯¢è¿½è¸ª
    user, err := getUserFromDB(ctx, userID)
    if err != nil {
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(
        attribute.String("user.email", user.Email),
        attribute.Bool("user.active", user.Active),
    )
    
    return user, nil
}

func getUserFromDB(ctx context.Context, userID string) (*User, error) {
    tracer := otel.Tracer("user-service")
    ctx, span := tracer.Start(ctx, "getUserFromDB")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.operation", "SELECT"),
        attribute.String("db.statement", "SELECT * FROM users WHERE id = ?"),
    )
    
    // æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢
    return db.QueryUser(ctx, userID)
}
```

### ğŸ“Š **æ€§èƒ½åŸºå‡†æµ‹è¯•**

#### å‹åŠ›æµ‹è¯•é…ç½®
```yaml
# K6æ€§èƒ½æµ‹è¯•
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-test-script
data:
  load-test.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    
    export let options = {
      stages: [
        { duration: '2m', target: 100 },  // 2åˆ†é’Ÿå†…é€æ¸å¢åŠ åˆ°100ä¸ªç”¨æˆ·
        { duration: '5m', target: 100 },  // 5åˆ†é’Ÿä¿æŒ100ä¸ªç”¨æˆ·
        { duration: '2m', target: 200 },  // 2åˆ†é’Ÿå†…å¢åŠ åˆ°200ä¸ªç”¨æˆ·
        { duration: '5m', target: 200 },  // 5åˆ†é’Ÿä¿æŒ200ä¸ªç”¨æˆ·
        { duration: '2m', target: 0 },    // 2åˆ†é’Ÿå†…å‡å°‘åˆ°0ä¸ªç”¨æˆ·
      ],
      thresholds: {
        http_req_duration: ['p(95)<500'],  // 95%çš„è¯·æ±‚å“åº”æ—¶é—´å°äº500ms
        http_req_failed: ['rate<0.1'],     // é”™è¯¯ç‡å°äº10%
      },
    };
    
    export default function() {
      // æµ‹è¯•ç”¨æˆ·API
      let response = http.get('http://user-service:8080/users/123');
      check(response, {
        'status is 200': (r) => r.status === 200,
        'response time < 500ms': (r) => r.timings.duration < 500,
      });
      
      // æµ‹è¯•åˆ›å»ºç”¨æˆ·API
      let payload = JSON.stringify({
        name: 'Test User',
        email: 'test@example.com',
      });
      
      response = http.post('http://user-service:8080/users', payload, {
        headers: { 'Content-Type': 'application/json' },
      });
      
      check(response, {
        'create user status is 201': (r) => r.status === 201,
      });
      
      sleep(1);
    }
---
apiVersion: batch/v1
kind: Job
metadata:
  name: k6-load-test
spec:
  template:
    spec:
      containers:
      - name: k6
        image: grafana/k6:latest
        command: ["k6", "run", "/scripts/load-test.js"]
        volumeMounts:
        - name: test-script
          mountPath: /scripts
      volumes:
      - name: test-script
        configMap:
          name: k6-test-script
      restartPolicy: Never
```

#### æ€§èƒ½åˆ†æå’Œä¼˜åŒ–
```go
// æ€§èƒ½åˆ†æå·¥å…·é›†æˆ
package main

import (
    "context"
    "net/http"
    _ "net/http/pprof"
    "time"
    
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

// PrometheusæŒ‡æ ‡å®šä¹‰
var (
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )
    
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_request_duration_seconds",
            Help:    "Duration of HTTP requests in seconds",
            Buckets: prometheus.DefBuckets,
        },
        []string{"method", "endpoint"},
    )
    
    databaseConnectionPool = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "database_connections",
            Help: "Number of database connections",
        },
        []string{"state"}, // active, idle, waiting
    )
    
    cacheHitRatio = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "cache_hit_ratio",
            Help: "Cache hit ratio",
        },
        []string{"cache_level"},
    )
)

// æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
func performanceMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // åŒ…è£…ResponseWriterä»¥æ•è·çŠ¶æ€ç 
        wrappedWriter := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        // æ‰§è¡Œè¯·æ±‚
        next(wrappedWriter, r)
        
        // è®°å½•æŒ‡æ ‡
        duration := time.Since(start).Seconds()
        httpRequestDuration.WithLabelValues(r.Method, r.URL.Path).Observe(duration)
        httpRequestsTotal.WithLabelValues(r.Method, r.URL.Path, string(wrappedWriter.statusCode)).Inc()
    }
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

// æ•°æ®åº“è¿æ¥æ± ç›‘æ§
func monitorDatabasePool(db *sql.DB) {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for range ticker.C {
            stats := db.Stats()
            databaseConnectionPool.WithLabelValues("open").Set(float64(stats.OpenConnections))
            databaseConnectionPool.WithLabelValues("in_use").Set(float64(stats.InUse))
            databaseConnectionPool.WithLabelValues("idle").Set(float64(stats.Idle))
            databaseConnectionPool.WithLabelValues("waiting").Set(float64(stats.WaitCount))
        }
    }()
}

// ç¼“å­˜æ€§èƒ½ç›‘æ§
type CacheMetrics struct {
    hits   int64
    misses int64
}

func (c *CacheMetrics) RecordHit() {
    atomic.AddInt64(&c.hits, 1)
    c.updateRatio()
}

func (c *CacheMetrics) RecordMiss() {
    atomic.AddInt64(&c.misses, 1)
    c.updateRatio()
}

func (c *CacheMetrics) updateRatio() {
    total := c.hits + c.misses
    if total > 0 {
        ratio := float64(c.hits) / float64(total)
        cacheHitRatio.WithLabelValues("l1").Set(ratio)
    }
}

func main() {
    // å¯åŠ¨pprofæœåŠ¡
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()
    
    // å¯åŠ¨PrometheusæŒ‡æ ‡æœåŠ¡
    http.Handle("/metrics", promhttp.Handler())
    
    // ä¸šåŠ¡è·¯ç”±
    http.HandleFunc("/users", performanceMiddleware(getUsersHandler))
    http.HandleFunc("/health", healthCheckHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

---

## å®è·µç¯å¢ƒæ­å»º

### ğŸ–¥ï¸ **å®Œæ•´å®éªŒç¯å¢ƒ**

#### åŸºç¡€è®¾æ–½æ­å»º
```bash
#!/bin/bash
# é«˜çº§ç³»ç»Ÿæ¶æ„å®éªŒç¯å¢ƒæ­å»ºè„šæœ¬

# 1. åˆ›å»ºKubernetesé›†ç¾¤
echo "åˆ›å»ºKubernetesé›†ç¾¤..."
kind create cluster --config - <<EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: InitConfiguration
    nodeRegistration:
      kubeletExtraArgs:
        node-labels: "ingress-ready=true"
  extraPortMappings:
  - containerPort: 80
    hostPort: 80
    protocol: TCP
  - containerPort: 443
    hostPort: 443
    protocol: TCP
- role: worker
- role: worker
- role: worker
EOF

# 2. å®‰è£…Istio Service Mesh
echo "å®‰è£…Istio..."
curl -L https://istio.io/downloadIstio | sh -
sudo mv istio-*/bin/istioctl /usr/local/bin/
istioctl install --set values.defaultRevision=default -y
kubectl label namespace default istio-injection=enabled

# 3. å®‰è£…ç›‘æ§æ ˆ
echo "å®‰è£…Prometheus + Grafana..."
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update

helm install prometheus prometheus-community/kube-prometheus-stack \
  --namespace monitoring \
  --create-namespace \
  --set grafana.adminPassword=admin123

# 4. å®‰è£…Jaeger
echo "å®‰è£…Jaeger..."
kubectl create namespace observability
kubectl apply -n observability -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.45.0/jaeger-operator.yaml

# 5. å®‰è£…æ•°æ®åº“
echo "å®‰è£…PostgreSQL..."
helm repo add bitnami https://charts.bitnami.com/bitnami
helm install postgresql bitnami/postgresql \
  --set auth.postgresPassword=postgres123 \
  --set primary.persistence.size=20Gi

# 6. å®‰è£…Redisé›†ç¾¤
echo "å®‰è£…Redis..."
helm install redis bitnami/redis-cluster \
  --set auth.enabled=false \
  --set persistence.size=10Gi

# 7. å®‰è£…æ¶ˆæ¯é˜Ÿåˆ—
echo "å®‰è£…Kafka..."
helm repo add confluentinc https://confluentinc.github.io/cp-helm-charts/
helm install kafka confluentinc/cp-helm-charts \
  --set cp-schema-registry.enabled=false \
  --set cp-kafka-rest.enabled=false \
  --set cp-kafka-connect.enabled=false

echo "ç¯å¢ƒæ­å»ºå®Œæˆï¼"
echo "è®¿é—®åœ°å€ï¼š"
echo "- Grafana: http://localhost:3000 (admin/admin123)"
echo "- Prometheus: http://localhost:9090"
echo "- Jaeger: http://localhost:16686"
```

#### å¼€å‘å·¥å…·é…ç½®
```yaml
# VS Codeå¼€å‘ç¯å¢ƒé…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: vscode-config
data:
  settings.json: |
    {
      "go.toolsManagement.autoUpdate": true,
      "go.useLanguageServer": true,
      "go.lintTool": "golangci-lint",
      "go.formatTool": "goimports",
      "kubernetes.defaultNamespace": "default",
      "kubernetes.outputFormat": "yaml",
      "docker.showStartPage": false,
      "yaml.schemas": {
        "kubernetes": "*.k8s.yaml"
      },
      "terraform.experimentalFeatures": {
        "validateOnSave": true
      }
    }
  
  extensions.txt: |
    ms-vscode.Go
    ms-kubernetes-tools.vscode-kubernetes-tools
    ms-azuretools.vscode-docker
    HashiCorp.terraform
    redhat.vscode-yaml
    ms-vscode.vscode-json
    Gruntfuggly.todo-tree
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vscode-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vscode-server
  template:
    metadata:
      labels:
        app: vscode-server
    spec:
      containers:
      - name: vscode
        image: codercom/code-server:latest
        ports:
        - containerPort: 8080
        env:
        - name: PASSWORD
          value: "codeserver123"
        volumeMounts:
        - name: workspace
          mountPath: /home/coder/workspace
        - name: config
          mountPath: /home/coder/.local/share/code-server/User
      volumes:
      - name: workspace
        persistentVolumeClaim:
          claimName: workspace-pvc
      - name: config
        configMap:
          name: vscode-config
```

---

## æ¶æ„è®¾è®¡å®æˆ˜

### ğŸ¯ **å®æˆ˜é¡¹ç›®ï¼šåˆ†å¸ƒå¼ç”µå•†å¹³å°**

#### ç³»ç»Ÿæ¶æ„è®¾è®¡
```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Load Balancer â”‚
                    â”‚   (Nginx/Kong)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   API Gateway     â”‚           â”‚   Web Gateway     â”‚
    â”‚   (Kong/Zuul)     â”‚           â”‚   (Nginx/Traefik) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              Service Mesh (Istio)                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   User Services   â”‚           â”‚ Product Services  â”‚
    â”‚                   â”‚           â”‚                   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚           â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ User Service  â”‚ â”‚           â”‚ â”‚Product Serviceâ”‚ â”‚
    â”‚ â”‚ Auth Service  â”‚ â”‚           â”‚ â”‚Inventory Svc  â”‚ â”‚
    â”‚ â”‚Profile Serviceâ”‚ â”‚           â”‚ â”‚Category Svc   â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Order Services  â”‚           â”‚ Payment Services  â”‚
    â”‚                   â”‚           â”‚                   â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚           â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ Order Service â”‚ â”‚           â”‚ â”‚Payment Serviceâ”‚ â”‚
    â”‚ â”‚Cart Service   â”‚ â”‚           â”‚ â”‚Invoice Serviceâ”‚ â”‚
    â”‚ â”‚Shipping Svc   â”‚ â”‚           â”‚ â”‚Refund Service â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                Data Layer                        â”‚
    â”‚                                                  â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
    â”‚ â”‚PostgreSQLâ”‚ â”‚  Redis   â”‚ â”‚  Kafka   â”‚          â”‚
    â”‚ â”‚ Cluster  â”‚ â”‚ Cluster  â”‚ â”‚ Cluster  â”‚          â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å¾®æœåŠ¡å®ç°

**ç”¨æˆ·æœåŠ¡å®ç°**:
```go
// cmd/user-service/main.go
package main

import (
    "context"
    "log"
    "net"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/reflection"
    
    "github.com/company/ecommerce/internal/user"
    pb "github.com/company/ecommerce/proto/user"
)

func main() {
    lis, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatalf("Failed to listen: %v", err)
    }
    
    // åˆ›å»ºç”¨æˆ·æœåŠ¡
    userRepo := user.NewPostgreSQLRepository()
    userService := user.NewService(userRepo)
    
    // åˆ›å»ºgRPCæœåŠ¡å™¨
    server := grpc.NewServer()
    pb.RegisterUserServiceServer(server, &userServiceServer{
        service: userService,
    })
    
    // å¯ç”¨åå°„ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    reflection.Register(server)
    
    log.Println("User service starting on :8080")
    if err := server.Serve(lis); err != nil {
        log.Fatalf("Failed to serve: %v", err)
    }
}

type userServiceServer struct {
    pb.UnimplementedUserServiceServer
    service user.Service
}

func (s *userServiceServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
    user := &user.User{
        Email:    req.Email,
        Name:     req.Name,
        Password: req.Password,
    }
    
    createdUser, err := s.service.CreateUser(ctx, user)
    if err != nil {
        return nil, err
    }
    
    return &pb.CreateUserResponse{
        User: &pb.User{
            Id:    createdUser.ID,
            Email: createdUser.Email,
            Name:  createdUser.Name,
        },
    }, nil
}
```

**è®¢å•æœåŠ¡å®ç°**:
```go
// internal/order/service.go
package order

import (
    "context"
    "fmt"
    
    "github.com/company/ecommerce/internal/events"
)

type Service interface {
    CreateOrder(ctx context.Context, order *Order) (*Order, error)
    GetOrder(ctx context.Context, orderID string) (*Order, error)
    UpdateOrderStatus(ctx context.Context, orderID string, status OrderStatus) error
}

type service struct {
    repo      Repository
    eventBus  events.EventBus
    inventory InventoryClient
    payment   PaymentClient
}

func NewService(repo Repository, eventBus events.EventBus, inventory InventoryClient, payment PaymentClient) Service {
    return &service{
        repo:      repo,
        eventBus:  eventBus,
        inventory: inventory,
        payment:   payment,
    }
}

func (s *service) CreateOrder(ctx context.Context, order *Order) (*Order, error) {
    // 1. éªŒè¯åº“å­˜
    for _, item := range order.Items {
        available, err := s.inventory.CheckAvailability(ctx, item.ProductID, item.Quantity)
        if err != nil {
            return nil, fmt.Errorf("failed to check inventory: %w", err)
        }
        if !available {
            return nil, fmt.Errorf("insufficient inventory for product %s", item.ProductID)
        }
    }
    
    // 2. é¢„æ‰£åº“å­˜
    for _, item := range order.Items {
        if err := s.inventory.ReserveInventory(ctx, item.ProductID, item.Quantity); err != nil {
            // å›æ»šå·²é¢„æ‰£çš„åº“å­˜
            s.rollbackInventoryReservation(ctx, order)
            return nil, fmt.Errorf("failed to reserve inventory: %w", err)
        }
    }
    
    // 3. åˆ›å»ºè®¢å•
    order.Status = OrderStatusPending
    createdOrder, err := s.repo.Create(ctx, order)
    if err != nil {
        s.rollbackInventoryReservation(ctx, order)
        return nil, fmt.Errorf("failed to create order: %w", err)
    }
    
    // 4. å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    event := &events.OrderCreatedEvent{
        OrderID:   createdOrder.ID,
        UserID:    createdOrder.UserID,
        Amount:    createdOrder.TotalAmount,
        Timestamp: createdOrder.CreatedAt,
    }
    
    if err := s.eventBus.Publish(ctx, "order.created", event); err != nil {
        log.Printf("Failed to publish order created event: %v", err)
    }
    
    return createdOrder, nil
}

func (s *service) rollbackInventoryReservation(ctx context.Context, order *Order) {
    for _, item := range order.Items {
        if err := s.inventory.ReleaseReservation(ctx, item.ProductID, item.Quantity); err != nil {
            log.Printf("Failed to rollback inventory reservation: %v", err)
        }
    }
}
```

#### éƒ¨ç½²é…ç½®

**Kuberneteséƒ¨ç½²æ¸…å•**:
```yaml
# user-serviceéƒ¨ç½²
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: user-service
        image: ecommerce/user-service:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          value: "redis://redis-cluster:6379"
        - name: JAEGER_ENDPOINT
          value: "http://jaeger-collector:14268/api/traces"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          grpc:
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          grpc:
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
  labels:
    app: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 8080
    targetPort: 8080
    name: grpc
---
# Istio VirtualService
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - match:
    - uri:
        prefix: /users
    route:
    - destination:
        host: user-service
        port:
          number: 8080
    fault:
      delay:
        percentage:
          value: 0.1
        fixedDelay: 5s
    retries:
      attempts: 3
      perTryTimeout: 10s
```

### âœ… **éªŒæ”¶æ ‡å‡†**

å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

**æ¶æ„è®¾è®¡èƒ½åŠ›**:
- [ ] è®¾è®¡æ”¯æŒç™¾ä¸‡ç”¨æˆ·çš„åˆ†å¸ƒå¼ç³»ç»Ÿæ¶æ„
- [ ] åˆç†é€‰æ‹©å’Œåº”ç”¨åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æ¨¡å¼
- [ ] è®¾è®¡é«˜å¯ç”¨ã€é«˜æ€§èƒ½çš„æ•°æ®æ¶æ„
- [ ] å®æ–½æœ‰æ•ˆçš„å®¹é”™å’Œæ¢å¤æœºåˆ¶

**æŠ€æœ¯å®ç°èƒ½åŠ›**:
- [ ] å®ç°å®Œæ•´çš„å¾®æœåŠ¡ç³»ç»Ÿ
- [ ] é…ç½®å’Œç®¡ç†Service Mesh
- [ ] å»ºç«‹åˆ†å¸ƒå¼è¿½è¸ªå’Œç›‘æ§ä½“ç³»
- [ ] è¿›è¡Œç³»ç»Ÿæ€§èƒ½è°ƒä¼˜å’Œå®¹é‡è§„åˆ’

**é—®é¢˜è§£å†³èƒ½åŠ›**:
- [ ] å¿«é€Ÿå®šä½å’Œè§£å†³åˆ†å¸ƒå¼ç³»ç»Ÿé—®é¢˜
- [ ] è¿›è¡Œç³»ç»Ÿæ€§èƒ½ç“¶é¢ˆåˆ†æ
- [ ] è®¾è®¡å’Œå®æ–½ç³»ç»Ÿæ‰©å®¹æ–¹æ¡ˆ
- [ ] å¤„ç†å¤æ‚çš„æ•°æ®ä¸€è‡´æ€§é—®é¢˜

---

*ä¸‹ä¸€ç« : [å¾®æœåŠ¡æ¶æ„å®è·µ](./å¾®æœåŠ¡æ¶æ„å®è·µ.md)*