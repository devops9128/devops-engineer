# å¾®æœåŠ¡æ¶æ„å®è·µ

> ä»å•ä½“åº”ç”¨åˆ°å¾®æœåŠ¡æ¶æ„çš„å®Œæ•´å®è·µæŒ‡å—

## ğŸ“š ç›®å½•

- [å¾®æœåŠ¡è®¾è®¡åŸåˆ™](#å¾®æœåŠ¡è®¾è®¡åŸåˆ™)
- [æœåŠ¡æ‹†åˆ†ç­–ç•¥](#æœåŠ¡æ‹†åˆ†ç­–ç•¥)
- [APIç½‘å…³æ¶æ„](#APIç½‘å…³æ¶æ„)
- [æœåŠ¡å‘ç°ä¸æ³¨å†Œ](#æœåŠ¡å‘ç°ä¸æ³¨å†Œ)
- [åˆ†å¸ƒå¼æ•°æ®ç®¡ç†](#åˆ†å¸ƒå¼æ•°æ®ç®¡ç†)
- [æœåŠ¡é—´é€šä¿¡æ¨¡å¼](#æœåŠ¡é—´é€šä¿¡æ¨¡å¼)
- [å¾®æœåŠ¡æ²»ç†](#å¾®æœåŠ¡æ²»ç†)
- [å®æˆ˜é¡¹ç›®å®æ–½](#å®æˆ˜é¡¹ç›®å®æ–½)

---

## å¾®æœåŠ¡è®¾è®¡åŸåˆ™

### ğŸ¯ **å¾®æœåŠ¡æ ¸å¿ƒåŸåˆ™**

#### å•ä¸€èŒè´£åŸåˆ™
```
æ¯ä¸ªå¾®æœåŠ¡åº”è¯¥åªæœ‰ä¸€ä¸ªæ”¹å˜çš„ç†ç”±
- ä¸šåŠ¡èŒè´£å•ä¸€
- æ•°æ®è®¿é—®ç‹¬ç«‹
- éƒ¨ç½²å•å…ƒç‹¬ç«‹
- å›¢é˜Ÿè´£ä»»æ˜ç¡®
```

#### å»ä¸­å¿ƒåŒ–æ²»ç†
```
é¿å…ä¼ä¸šçº§æœåŠ¡æ€»çº¿ (ESB)
- æ™ºèƒ½ç«¯ç‚¹ï¼Œæ„šç¬¨ç®¡é“
- æœåŠ¡è‡ªæ²»å†³ç­–
- æŠ€æœ¯æ ˆå¤šæ ·åŒ–
- ç‹¬ç«‹çš„æ•°æ®ç®¡ç†
```

#### å®¹é”™è®¾è®¡
```
æ‹¥æŠ±å¤±è´¥ï¼Œè®¾è®¡å®¹é”™
- æœåŠ¡é™çº§
- ç†”æ–­æœºåˆ¶
- è¶…æ—¶é‡è¯•
- ç›‘æ§å‘Šè­¦
```

### ğŸ—ï¸ **å¾®æœåŠ¡è¾¹ç•Œå®šä¹‰**

#### ä¸šåŠ¡èƒ½åŠ›æ˜ å°„
```yaml
# ç”µå•†å¹³å°ä¸šåŠ¡èƒ½åŠ›åˆ†è§£
business_capabilities:
  user_management:
    services:
      - user-service
      - auth-service
      - profile-service
    data_ownership:
      - users
      - user_profiles
      - authentication_tokens
    
  product_catalog:
    services:
      - product-service
      - inventory-service
      - category-service
    data_ownership:
      - products
      - inventory
      - categories
    
  order_management:
    services:
      - order-service
      - cart-service
      - shipping-service
    data_ownership:
      - orders
      - shopping_carts
      - shipments
    
  payment_processing:
    services:
      - payment-service
      - billing-service
      - refund-service
    data_ownership:
      - payments
      - billing_records
      - refunds
```

#### æ•°æ®ä¸€è‡´æ€§è¾¹ç•Œ
```go
// èšåˆæ ¹å®šä¹‰
package domain

// Orderèšåˆæ ¹
type Order struct {
    ID          string
    UserID      string
    Items       []OrderItem
    Status      OrderStatus
    TotalAmount decimal.Decimal
    CreatedAt   time.Time
    UpdatedAt   time.Time
}

// OrderItemå€¼å¯¹è±¡
type OrderItem struct {
    ProductID string
    Quantity  int
    Price     decimal.Decimal
}

// ä¸šåŠ¡è§„åˆ™åœ¨èšåˆå†…éƒ¨ç»´æŠ¤
func (o *Order) AddItem(productID string, quantity int, price decimal.Decimal) error {
    if o.Status != OrderStatusDraft {
        return errors.New("cannot modify confirmed order")
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥å•†å“
    for i, item := range o.Items {
        if item.ProductID == productID {
            o.Items[i].Quantity += quantity
            o.calculateTotal()
            return nil
        }
    }
    
    // æ·»åŠ æ–°å•†å“
    o.Items = append(o.Items, OrderItem{
        ProductID: productID,
        Quantity:  quantity,
        Price:     price,
    })
    
    o.calculateTotal()
    return nil
}

func (o *Order) calculateTotal() {
    total := decimal.Zero
    for _, item := range o.Items {
        itemTotal := item.Price.Mul(decimal.NewFromInt(int64(item.Quantity)))
        total = total.Add(itemTotal)
    }
    o.TotalAmount = total
}
```

---

## æœåŠ¡æ‹†åˆ†ç­–ç•¥

### ğŸ“Š **é¢†åŸŸé©±åŠ¨æ‹†åˆ†æ³•**

#### é™ç•Œä¸Šä¸‹æ–‡è¯†åˆ«
```
ç”¨æˆ·ä¸Šä¸‹æ–‡ (User Context)
â”œâ”€â”€ èº«ä»½è®¤è¯ (Authentication)
â”œâ”€â”€ ç”¨æˆ·ç”»åƒ (User Profile)
â””â”€â”€ æƒé™ç®¡ç† (Authorization)

å•†å“ä¸Šä¸‹æ–‡ (Product Context)
â”œâ”€â”€ å•†å“ä¿¡æ¯ (Product Information)
â”œâ”€â”€ åº“å­˜ç®¡ç† (Inventory Management)
â””â”€â”€ ä»·æ ¼ç­–ç•¥ (Pricing Strategy)

è®¢å•ä¸Šä¸‹æ–‡ (Order Context)
â”œâ”€â”€ è´­ç‰©è½¦ (Shopping Cart)
â”œâ”€â”€ è®¢å•å¤„ç† (Order Processing)
â””â”€â”€ æ”¯ä»˜æµç¨‹ (Payment Flow)
```

#### æœåŠ¡æ‹†åˆ†å®æ–½æ­¥éª¤
```bash
# æ­¥éª¤1: è¯†åˆ«ä¸šåŠ¡è¾¹ç•Œ
./scripts/analyze-business-boundaries.sh

# æ­¥éª¤2: åˆ†ææ•°æ®ä¾èµ–
./scripts/analyze-data-dependencies.sh

# æ­¥éª¤3: è¯„ä¼°å›¢é˜Ÿç»“æ„
./scripts/analyze-team-structure.sh

# æ­¥éª¤4: åˆ¶å®šæ‹†åˆ†è®¡åˆ’
./scripts/create-migration-plan.sh
```

### ğŸ”„ **æ‹†åˆ†ç­–ç•¥å®ç°**

#### ç»æ€è€…æ¨¡å¼ (Strangler Fig Pattern)
```yaml
# Phase 1: è·¯ç”±å±‚å¼•å…¥
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-migration
spec:
  hosts:
  - api.company.com
  http:
  # æ–°åŠŸèƒ½è·¯ç”±åˆ°å¾®æœåŠ¡
  - match:
    - uri:
        prefix: /api/v2/users
    route:
    - destination:
        host: user-service
        port:
          number: 8080
      weight: 100
  
  # æ—§åŠŸèƒ½ç»§ç»­ä½¿ç”¨å•ä½“åº”ç”¨
  - match:
    - uri:
        prefix: /api/v1/users
    route:
    - destination:
        host: monolith-app
        port:
          number: 8080
      weight: 100
---
# Phase 2: é€æ­¥è¿ç§»æµé‡
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-migration-canary
spec:
  hosts:
  - api.company.com
  http:
  - match:
    - uri:
        prefix: /api/users
    route:
    - destination:
        host: user-service
        port:
          number: 8080
      weight: 20  # 20%æµé‡åˆ°æ–°æœåŠ¡
    - destination:
        host: monolith-app
        port:
          number: 8080
      weight: 80  # 80%æµé‡åˆ°å•ä½“åº”ç”¨
```

#### æ•°æ®åŒæ­¥ç­–ç•¥
```go
// åŒå†™æ¨¡å¼å®ç°
package migration

import (
    "context"
    "log"
)

type DualWriteUserRepository struct {
    legacyRepo UserRepository
    newRepo    UserRepository
    syncMode   SyncMode
}

type SyncMode int

const (
    SyncModeAsync SyncMode = iota
    SyncModeSync
)

func (d *DualWriteUserRepository) CreateUser(ctx context.Context, user *User) error {
    // ä¸»å†™å…¥åˆ°æ–°ç³»ç»Ÿ
    if err := d.newRepo.CreateUser(ctx, user); err != nil {
        return err
    }
    
    // åŒæ­¥åˆ°æ—§ç³»ç»Ÿ
    switch d.syncMode {
    case SyncModeSync:
        if err := d.legacyRepo.CreateUser(ctx, user); err != nil {
            log.Printf("Failed to sync user to legacy system: %v", err)
            // å¯ä»¥é€‰æ‹©å›æ»šæ–°ç³»ç»Ÿæˆ–ç»§ç»­
            return err
        }
    case SyncModeAsync:
        go func() {
            if err := d.legacyRepo.CreateUser(context.Background(), user); err != nil {
                log.Printf("Failed to async sync user to legacy system: %v", err)
                // å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—æˆ–é‡è¯•é˜Ÿåˆ—
                d.handleSyncFailure(user, err)
            }
        }()
    }
    
    return nil
}

func (d *DualWriteUserRepository) handleSyncFailure(user *User, err error) {
    // å®ç°é‡è¯•é€»è¾‘æˆ–å°†å¤±è´¥è®°å½•å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—
    event := &SyncFailureEvent{
        Entity: "user",
        ID:     user.ID,
        Data:   user,
        Error:  err.Error(),
    }
    
    // å‘é€åˆ°é‡è¯•é˜Ÿåˆ—
    retryQueue.Publish(event)
}
```

---

## APIç½‘å…³æ¶æ„

### ğŸŒ **ç½‘å…³åŠŸèƒ½è®¾è®¡**

#### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
```
API Gateway
â”œâ”€â”€ è·¯ç”±ç®¡ç† (Routing)
â”œâ”€â”€ è´Ÿè½½å‡è¡¡ (Load Balancing)
â”œâ”€â”€ è®¤è¯æˆæƒ (Authentication & Authorization)
â”œâ”€â”€ é™æµç†”æ–­ (Rate Limiting & Circuit Breaking)
â”œâ”€â”€ åè®®è½¬æ¢ (Protocol Translation)
â”œâ”€â”€ ç›‘æ§æ—¥å¿— (Monitoring & Logging)
â”œâ”€â”€ ç¼“å­˜ç­–ç•¥ (Caching)
â””â”€â”€ APIç‰ˆæœ¬ç®¡ç† (API Versioning)
```

#### Kongç½‘å…³é…ç½®
```yaml
# Kong Gatewayé…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: kong-config
data:
  kong.yaml: |
    _format_version: "3.0"
    
    services:
    - name: user-service
      url: http://user-service:8080
      plugins:
      - name: jwt
        config:
          secret_is_base64: false
      - name: rate-limiting
        config:
          minute: 100
          hour: 1000
    
    - name: product-service
      url: http://product-service:8080
      plugins:
      - name: cors
        config:
          origins:
          - "*"
          methods:
          - GET
          - POST
          - PUT
          - DELETE
    
    routes:
    - name: user-routes
      service: user-service
      paths:
      - /api/users
      - /api/auth
      strip_path: false
    
    - name: product-routes
      service: product-service
      paths:
      - /api/products
      - /api/inventory
      strip_path: false
    
    consumers:
    - username: mobile-app
      keyauth_credentials:
      - key: mobile-app-key-2023
    
    - username: web-app
      jwt_credentials:
      - key: web-app-jwt
        secret: web-app-secret-2023
    
    plugins:
    - name: prometheus
      config:
        per_consumer: true
        status_code_metrics: true
        latency_metrics: true
        bandwidth_metrics: true
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kong-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: kong-gateway
  template:
    metadata:
      labels:
        app: kong-gateway
    spec:
      containers:
      - name: kong
        image: kong:3.4
        ports:
        - containerPort: 8000
        - containerPort: 8001
        - containerPort: 8443
        - containerPort: 8444
        env:
        - name: KONG_DATABASE
          value: "off"
        - name: KONG_DECLARATIVE_CONFIG
          value: "/kong/kong.yaml"
        - name: KONG_PROXY_ACCESS_LOG
          value: "/dev/stdout"
        - name: KONG_ADMIN_ACCESS_LOG
          value: "/dev/stdout"
        - name: KONG_PROXY_ERROR_LOG
          value: "/dev/stderr"
        - name: KONG_ADMIN_ERROR_LOG
          value: "/dev/stderr"
        - name: KONG_ADMIN_LISTEN
          value: "0.0.0.0:8001"
        volumeMounts:
        - name: kong-config
          mountPath: /kong
      volumes:
      - name: kong-config
        configMap:
          name: kong-config
```

#### è‡ªå®šä¹‰ç½‘å…³å®ç°
```go
// ç®€åŒ–çš„APIç½‘å…³å®ç°
package gateway

import (
    "context"
    "fmt"
    "net/http"
    "net/http/httputil"
    "net/url"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
    "golang.org/x/time/rate"
)

type Gateway struct {
    router      *gin.Engine
    services    map[string]*ServiceConfig
    rateLimiter *rate.Limiter
    auth        AuthService
    metrics     MetricsCollector
}

type ServiceConfig struct {
    Name     string
    BaseURL  *url.URL
    HealthCheck string
    Timeout  time.Duration
    Retries  int
}

func NewGateway(services map[string]*ServiceConfig) *Gateway {
    gw := &Gateway{
        router:      gin.New(),
        services:    services,
        rateLimiter: rate.NewLimiter(rate.Limit(1000), 100), // 1000 RPS with burst of 100
        auth:        NewJWTAuthService(),
        metrics:     NewPrometheusMetrics(),
    }
    
    gw.setupMiddleware()
    gw.setupRoutes()
    
    return gw
}

func (gw *Gateway) setupMiddleware() {
    // æ—¥å¿—ä¸­é—´ä»¶
    gw.router.Use(gin.LoggerWithConfig(gin.LoggerConfig{
        Formatter: func(param gin.LogFormatterParams) string {
            return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
                param.ClientIP,
                param.TimeStamp.Format(time.RFC1123),
                param.Method,
                param.Path,
                param.Request.Proto,
                param.StatusCode,
                param.Latency,
                param.Request.UserAgent(),
                param.ErrorMessage,
            )
        },
    }))
    
    // æ¢å¤ä¸­é—´ä»¶
    gw.router.Use(gin.Recovery())
    
    // CORSä¸­é—´ä»¶
    gw.router.Use(func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Authorization")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    })
    
    // é™æµä¸­é—´ä»¶
    gw.router.Use(gw.rateLimitMiddleware())
    
    // è®¤è¯ä¸­é—´ä»¶
    gw.router.Use(gw.authMiddleware())
    
    // æŒ‡æ ‡æ”¶é›†ä¸­é—´ä»¶
    gw.router.Use(gw.metricsMiddleware())
}

func (gw *Gateway) rateLimitMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        if !gw.rateLimiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}

func (gw *Gateway) authMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // è·³è¿‡å¥åº·æ£€æŸ¥å’Œå…¬å¼€ç«¯ç‚¹
        if strings.HasPrefix(c.Request.URL.Path, "/health") ||
           strings.HasPrefix(c.Request.URL.Path, "/api/public") {
            c.Next()
            return
        }
        
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Authorization header required",
            })
            c.Abort()
            return
        }
        
        token := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := gw.auth.ValidateToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Invalid token",
            })
            c.Abort()
            return
        }
        
        c.Set("user_claims", claims)
        c.Next()
    }
}

func (gw *Gateway) metricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start)
        gw.metrics.RecordRequest(c.Request.Method, c.FullPath(), c.Writer.Status(), duration)
    }
}

func (gw *Gateway) setupRoutes() {
    // å¥åº·æ£€æŸ¥
    gw.router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "healthy",
            "timestamp": time.Now(),
        })
    })
    
    // åŠ¨æ€è·¯ç”±åˆ°åç«¯æœåŠ¡
    gw.router.Any("/api/*path", gw.proxyHandler)
}

func (gw *Gateway) proxyHandler(c *gin.Context) {
    path := c.Param("path")
    serviceName := gw.extractServiceName(path)
    
    service, exists := gw.services[serviceName]
    if !exists {
        c.JSON(http.StatusNotFound, gin.H{
            "error": "Service not found",
        })
        return
    }
    
    // åˆ›å»ºåå‘ä»£ç†
    proxy := httputil.NewSingleHostReverseProxy(service.BaseURL)
    
    // è‡ªå®šä¹‰é”™è¯¯å¤„ç†
    proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
        c.JSON(http.StatusBadGateway, gin.H{
            "error": "Service unavailable",
            "service": serviceName,
        })
    }
    
    // ä¿®æ”¹è¯·æ±‚
    proxy.ModifyResponse = func(resp *http.Response) error {
        resp.Header.Set("X-Gateway", "custom-gateway")
        return nil
    }
    
    proxy.ServeHTTP(c.Writer, c.Request)
}

func (gw *Gateway) extractServiceName(path string) string {
    parts := strings.Split(strings.Trim(path, "/"), "/")
    if len(parts) > 0 {
        return parts[0]
    }
    return ""
}
```

---

## æœåŠ¡å‘ç°ä¸æ³¨å†Œ

### ğŸ” **æœåŠ¡æ³¨å†Œä¸­å¿ƒæ¶æ„**

#### Consulé›†ç¾¤éƒ¨ç½²
```yaml
# Consulé›†ç¾¤é…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: consul-config
data:
  consul.json: |
    {
      "datacenter": "dc1",
      "data_dir": "/consul/data",
      "log_level": "INFO",
      "server": true,
      "bootstrap_expect": 3,
      "bind_addr": "0.0.0.0",
      "client_addr": "0.0.0.0",
      "retry_join": [
        "consul-0.consul-headless.default.svc.cluster.local",
        "consul-1.consul-headless.default.svc.cluster.local",
        "consul-2.consul-headless.default.svc.cluster.local"
      ],
      "ui_config": {
        "enabled": true
      },
      "connect": {
        "enabled": true
      },
      "acl": {
        "enabled": true,
        "default_policy": "deny",
        "enable_token_persistence": true
      }
    }
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: consul
spec:
  serviceName: consul-headless
  replicas: 3
  selector:
    matchLabels:
      app: consul
  template:
    metadata:
      labels:
        app: consul
    spec:
      containers:
      - name: consul
        image: consul:1.16.1
        ports:
        - containerPort: 8500
          name: ui
        - containerPort: 8300
          name: server
        - containerPort: 8301
          name: serf-lan
        - containerPort: 8302
          name: serf-wan
        - containerPort: 8600
          name: dns
        env:
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: CONSUL_LOCAL_CONFIG
          valueFrom:
            configMapKeyRef:
              name: consul-config
              key: consul.json
        volumeMounts:
        - name: consul-data
          mountPath: /consul/data
        - name: consul-config
          mountPath: /consul/config
        livenessProbe:
          httpGet:
            path: /v1/status/leader
            port: 8500
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /v1/status/leader
            port: 8500
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: consul-config
        configMap:
          name: consul-config
  volumeClaimTemplates:
  - metadata:
      name: consul-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

#### æœåŠ¡æ³¨å†Œå®ç°
```go
// æœåŠ¡æ³¨å†Œå®¢æˆ·ç«¯
package discovery

import (
    "fmt"
    "log"
    "time"
    
    "github.com/hashicorp/consul/api"
)

type ServiceRegistry struct {
    client *api.Client
    config *ServiceConfig
}

type ServiceConfig struct {
    ID       string
    Name     string
    Tags     []string
    Address  string
    Port     int
    Health   HealthCheck
}

type HealthCheck struct {
    HTTP                           string
    Interval                       time.Duration
    Timeout                        time.Duration
    DeregisterCriticalServiceAfter time.Duration
}

func NewServiceRegistry(consulAddr string, config *ServiceConfig) (*ServiceRegistry, error) {
    consulConfig := api.DefaultConfig()
    consulConfig.Address = consulAddr
    
    client, err := api.NewClient(consulConfig)
    if err != nil {
        return nil, err
    }
    
    return &ServiceRegistry{
        client: client,
        config: config,
    }, nil
}

func (sr *ServiceRegistry) Register() error {
    registration := &api.AgentServiceRegistration{
        ID:      sr.config.ID,
        Name:    sr.config.Name,
        Tags:    sr.config.Tags,
        Address: sr.config.Address,
        Port:    sr.config.Port,
        Check: &api.AgentServiceCheck{
            HTTP:                           sr.config.Health.HTTP,
            Interval:                       sr.config.Health.Interval.String(),
            Timeout:                        sr.config.Health.Timeout.String(),
            DeregisterCriticalServiceAfter: sr.config.Health.DeregisterCriticalServiceAfter.String(),
        },
    }
    
    if err := sr.client.Agent().ServiceRegister(registration); err != nil {
        return fmt.Errorf("failed to register service: %w", err)
    }
    
    log.Printf("Service %s registered successfully", sr.config.Name)
    return nil
}

func (sr *ServiceRegistry) Deregister() error {
    if err := sr.client.Agent().ServiceDeregister(sr.config.ID); err != nil {
        return fmt.Errorf("failed to deregister service: %w", err)
    }
    
    log.Printf("Service %s deregistered successfully", sr.config.Name)
    return nil
}

// æœåŠ¡å‘ç°å®¢æˆ·ç«¯
type ServiceDiscovery struct {
    client *api.Client
    cache  map[string][]*ServiceInstance
}

type ServiceInstance struct {
    ID      string
    Address string
    Port    int
    Tags    []string
    Health  string
}

func NewServiceDiscovery(consulAddr string) (*ServiceDiscovery, error) {
    config := api.DefaultConfig()
    config.Address = consulAddr
    
    client, err := api.NewClient(config)
    if err != nil {
        return nil, err
    }
    
    return &ServiceDiscovery{
        client: client,
        cache:  make(map[string][]*ServiceInstance),
    }, nil
}

func (sd *ServiceDiscovery) GetHealthyInstances(serviceName string) ([]*ServiceInstance, error) {
    services, _, err := sd.client.Health().Service(serviceName, "", true, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to get healthy instances: %w", err)
    }
    
    instances := make([]*ServiceInstance, 0, len(services))
    for _, service := range services {
        instances = append(instances, &ServiceInstance{
            ID:      service.Service.ID,
            Address: service.Service.Address,
            Port:    service.Service.Port,
            Tags:    service.Service.Tags,
            Health:  service.Checks.AggregatedStatus(),
        })
    }
    
    // æ›´æ–°ç¼“å­˜
    sd.cache[serviceName] = instances
    
    return instances, nil
}

func (sd *ServiceDiscovery) WatchService(serviceName string, callback func([]*ServiceInstance)) {
    go func() {
        lastIndex := uint64(0)
        for {
            services, meta, err := sd.client.Health().Service(serviceName, "", true, &api.QueryOptions{
                WaitIndex: lastIndex,
                WaitTime:  30 * time.Second,
            })
            
            if err != nil {
                log.Printf("Error watching service %s: %v", serviceName, err)
                time.Sleep(5 * time.Second)
                continue
            }
            
            lastIndex = meta.LastIndex
            
            instances := make([]*ServiceInstance, 0, len(services))
            for _, service := range services {
                instances = append(instances, &ServiceInstance{
                    ID:      service.Service.ID,
                    Address: service.Service.Address,
                    Port:    service.Service.Port,
                    Tags:    service.Service.Tags,
                    Health:  service.Checks.AggregatedStatus(),
                })
            }
            
            callback(instances)
        }
    }()
}
```

#### è´Ÿè½½å‡è¡¡å®ç°
```go
// è´Ÿè½½å‡è¡¡å™¨
package loadbalancer

import (
    "errors"
    "math/rand"
    "sync"
    "sync/atomic"
    "time"
)

type LoadBalancer interface {
    SelectInstance(instances []*ServiceInstance) (*ServiceInstance, error)
}

// è½®è¯¢è´Ÿè½½å‡è¡¡
type RoundRobinLoadBalancer struct {
    counter uint64
}

func (lb *RoundRobinLoadBalancer) SelectInstance(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, errors.New("no available instances")
    }
    
    index := atomic.AddUint64(&lb.counter, 1) % uint64(len(instances))
    return instances[index], nil
}

// åŠ æƒè½®è¯¢è´Ÿè½½å‡è¡¡
type WeightedRoundRobinLoadBalancer struct {
    mutex   sync.RWMutex
    weights map[string]*WeightedInstance
}

type WeightedInstance struct {
    Instance       *ServiceInstance
    Weight         int
    CurrentWeight  int
    EffectiveWeight int
}

func NewWeightedRoundRobinLoadBalancer() *WeightedRoundRobinLoadBalancer {
    return &WeightedRoundRobinLoadBalancer{
        weights: make(map[string]*WeightedInstance),
    }
}

func (lb *WeightedRoundRobinLoadBalancer) SelectInstance(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, errors.New("no available instances")
    }
    
    lb.mutex.Lock()
    defer lb.mutex.Unlock()
    
    // æ›´æ–°æƒé‡ä¿¡æ¯
    lb.updateWeights(instances)
    
    // é€‰æ‹©æƒé‡æœ€é«˜çš„å®ä¾‹
    var selected *WeightedInstance
    totalWeight := 0
    
    for _, weighted := range lb.weights {
        weighted.CurrentWeight += weighted.EffectiveWeight
        totalWeight += weighted.EffectiveWeight
        
        if selected == nil || weighted.CurrentWeight > selected.CurrentWeight {
            selected = weighted
        }
    }
    
    if selected != nil {
        selected.CurrentWeight -= totalWeight
        return selected.Instance, nil
    }
    
    return nil, errors.New("no available instances")
}

func (lb *WeightedRoundRobinLoadBalancer) updateWeights(instances []*ServiceInstance) {
    currentInstances := make(map[string]bool)
    
    for _, instance := range instances {
        key := fmt.Sprintf("%s:%d", instance.Address, instance.Port)
        currentInstances[key] = true
        
        if _, exists := lb.weights[key]; !exists {
            weight := lb.extractWeight(instance.Tags)
            lb.weights[key] = &WeightedInstance{
                Instance:        instance,
                Weight:          weight,
                CurrentWeight:   0,
                EffectiveWeight: weight,
            }
        }
    }
    
    // ç§»é™¤ä¸å­˜åœ¨çš„å®ä¾‹
    for key := range lb.weights {
        if !currentInstances[key] {
            delete(lb.weights, key)
        }
    }
}

func (lb *WeightedRoundRobinLoadBalancer) extractWeight(tags []string) int {
    for _, tag := range tags {
        if strings.HasPrefix(tag, "weight=") {
            if weight, err := strconv.Atoi(strings.TrimPrefix(tag, "weight=")); err == nil {
                return weight
            }
        }
    }
    return 1 // é»˜è®¤æƒé‡
}

// ä¸€è‡´æ€§å“ˆå¸Œè´Ÿè½½å‡è¡¡
type ConsistentHashLoadBalancer struct {
    hash     hash.Hash32
    replicas int
    keys     []uint32
    hashMap  map[uint32]*ServiceInstance
    mutex    sync.RWMutex
}

func NewConsistentHashLoadBalancer(replicas int) *ConsistentHashLoadBalancer {
    return &ConsistentHashLoadBalancer{
        hash:     crc32.NewIEEE(),
        replicas: replicas,
        hashMap:  make(map[uint32]*ServiceInstance),
    }
}

func (lb *ConsistentHashLoadBalancer) SelectInstance(instances []*ServiceInstance) (*ServiceInstance, error) {
    if len(instances) == 0 {
        return nil, errors.New("no available instances")
    }
    
    lb.mutex.Lock()
    lb.updateHashRing(instances)
    lb.mutex.Unlock()
    
    // ä½¿ç”¨è¯·æ±‚çš„æŸä¸ªå±æ€§ä½œä¸ºå“ˆå¸Œé”®ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
    key := fmt.Sprintf("request-%d", time.Now().UnixNano())
    return lb.selectByKey(key), nil
}

func (lb *ConsistentHashLoadBalancer) selectByKey(key string) *ServiceInstance {
    lb.mutex.RLock()
    defer lb.mutex.RUnlock()
    
    if len(lb.keys) == 0 {
        return nil
    }
    
    lb.hash.Reset()
    lb.hash.Write([]byte(key))
    hashValue := lb.hash.Sum32()
    
    // äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhashValueçš„èŠ‚ç‚¹
    idx := sort.Search(len(lb.keys), func(i int) bool {
        return lb.keys[i] >= hashValue
    })
    
    if idx == len(lb.keys) {
        idx = 0
    }
    
    return lb.hashMap[lb.keys[idx]]
}
```

---

## åˆ†å¸ƒå¼æ•°æ®ç®¡ç†

### ğŸ“Š **æ•°æ®ä¸€è‡´æ€§æ¨¡å¼**

#### Sagaæ¨¡å¼å®ç°
```go
// Sagaç¼–æ’å™¨
package saga

import (
    "context"
    "fmt"
    "log"
)

type SagaOrchestrator struct {
    steps []SagaStep
    state map[string]interface{}
}

type SagaStep interface {
    Execute(ctx context.Context, state map[string]interface{}) error
    Compensate(ctx context.Context, state map[string]interface{}) error
    Name() string
}

type SagaResult struct {
    Success bool
    Error   error
    Step    string
}

func NewSagaOrchestrator() *SagaOrchestrator {
    return &SagaOrchestrator{
        steps: make([]SagaStep, 0),
        state: make(map[string]interface{}),
    }
}

func (s *SagaOrchestrator) AddStep(step SagaStep) {
    s.steps = append(s.steps, step)
}

func (s *SagaOrchestrator) Execute(ctx context.Context) *SagaResult {
    executedSteps := make([]SagaStep, 0)
    
    // æ‰§è¡Œæ‰€æœ‰æ­¥éª¤
    for _, step := range s.steps {
        log.Printf("Executing saga step: %s", step.Name())
        
        if err := step.Execute(ctx, s.state); err != nil {
            log.Printf("Saga step %s failed: %v", step.Name(), err)
            
            // æ‰§è¡Œè¡¥å¿æ“ä½œ
            s.compensate(ctx, executedSteps)
            
            return &SagaResult{
                Success: false,
                Error:   err,
                Step:    step.Name(),
            }
        }
        
        executedSteps = append(executedSteps, step)
    }
    
    return &SagaResult{
        Success: true,
    }
}

func (s *SagaOrchestrator) compensate(ctx context.Context, executedSteps []SagaStep) {
    // é€†åºæ‰§è¡Œè¡¥å¿æ“ä½œ
    for i := len(executedSteps) - 1; i >= 0; i-- {
        step := executedSteps[i]
        log.Printf("Compensating saga step: %s", step.Name())
        
        if err := step.Compensate(ctx, s.state); err != nil {
            log.Printf("Compensation failed for step %s: %v", step.Name(), err)
            // è¡¥å¿å¤±è´¥å¯èƒ½éœ€è¦äººå·¥å¹²é¢„
        }
    }
}

// è®¢å•åˆ›å»ºSagaæ­¥éª¤
type CreateOrderStep struct {
    orderService OrderService
}

func (s *CreateOrderStep) Execute(ctx context.Context, state map[string]interface{}) error {
    orderRequest := state["order_request"].(*CreateOrderRequest)
    
    order, err := s.orderService.CreateOrder(ctx, orderRequest)
    if err != nil {
        return err
    }
    
    state["order_id"] = order.ID
    return nil
}

func (s *CreateOrderStep) Compensate(ctx context.Context, state map[string]interface{}) error {
    orderID := state["order_id"].(string)
    return s.orderService.CancelOrder(ctx, orderID)
}

func (s *CreateOrderStep) Name() string {
    return "CreateOrder"
}

// æ‰£å‡åº“å­˜Sagaæ­¥éª¤
type ReserveInventoryStep struct {
    inventoryService InventoryService
}

func (s *ReserveInventoryStep) Execute(ctx context.Context, state map[string]interface{}) error {
    orderRequest := state["order_request"].(*CreateOrderRequest)
    
    for _, item := range orderRequest.Items {
        if err := s.inventoryService.ReserveInventory(ctx, item.ProductID, item.Quantity); err != nil {
            return err
        }
    }
    
    return nil
}

func (s *ReserveInventoryStep) Compensate(ctx context.Context, state map[string]interface{}) error {
    orderRequest := state["order_request"].(*CreateOrderRequest)
    
    for _, item := range orderRequest.Items {
        if err := s.inventoryService.ReleaseReservation(ctx, item.ProductID, item.Quantity); err != nil {
            log.Printf("Failed to release inventory reservation: %v", err)
        }
    }
    
    return nil
}

func (s *ReserveInventoryStep) Name() string {
    return "ReserveInventory"
}

// å¤„ç†æ”¯ä»˜Sagaæ­¥éª¤
type ProcessPaymentStep struct {
    paymentService PaymentService
}

func (s *ProcessPaymentStep) Execute(ctx context.Context, state map[string]interface{}) error {
    orderRequest := state["order_request"].(*CreateOrderRequest)
    orderID := state["order_id"].(string)
    
    payment, err := s.paymentService.ProcessPayment(ctx, &PaymentRequest{
        OrderID: orderID,
        Amount:  orderRequest.TotalAmount,
        Method:  orderRequest.PaymentMethod,
    })
    
    if err != nil {
        return err
    }
    
    state["payment_id"] = payment.ID
    return nil
}

func (s *ProcessPaymentStep) Compensate(ctx context.Context, state map[string]interface{}) error {
    paymentID := state["payment_id"].(string)
    return s.paymentService.RefundPayment(ctx, paymentID)
}

func (s *ProcessPaymentStep) Name() string {
    return "ProcessPayment"
}
```

#### äº‹ä»¶æº¯æºå®ç°
```go
// äº‹ä»¶æº¯æºå®ç°
package eventsourcing

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
)

type Event interface {
    GetAggregateID() string
    GetEventType() string
    GetVersion() int
    GetTimestamp() time.Time
    GetData() interface{}
}

type BaseEvent struct {
    AggregateID string    `json:"aggregate_id"`
    EventType   string    `json:"event_type"`
    Version     int       `json:"version"`
    Timestamp   time.Time `json:"timestamp"`
    Data        []byte    `json:"data"`
}

func (e *BaseEvent) GetAggregateID() string { return e.AggregateID }
func (e *BaseEvent) GetEventType() string   { return e.EventType }
func (e *BaseEvent) GetVersion() int        { return e.Version }
func (e *BaseEvent) GetTimestamp() time.Time { return e.Timestamp }

func (e *BaseEvent) GetData() interface{} {
    var data interface{}
    json.Unmarshal(e.Data, &data)
    return data
}

// äº‹ä»¶å­˜å‚¨æ¥å£
type EventStore interface {
    SaveEvents(ctx context.Context, aggregateID string, events []Event, expectedVersion int) error
    LoadEvents(ctx context.Context, aggregateID string) ([]Event, error)
    LoadEventsFromVersion(ctx context.Context, aggregateID string, version int) ([]Event, error)
}

// PostgreSQLäº‹ä»¶å­˜å‚¨å®ç°
type PostgreSQLEventStore struct {
    db *sql.DB
}

func NewPostgreSQLEventStore(db *sql.DB) *PostgreSQLEventStore {
    return &PostgreSQLEventStore{db: db}
}

func (es *PostgreSQLEventStore) SaveEvents(ctx context.Context, aggregateID string, events []Event, expectedVersion int) error {
    tx, err := es.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // æ£€æŸ¥ç‰ˆæœ¬å†²çª
    var currentVersion int
    err = tx.QueryRowContext(ctx, 
        "SELECT COALESCE(MAX(version), 0) FROM events WHERE aggregate_id = $1", 
        aggregateID).Scan(&currentVersion)
    if err != nil && err != sql.ErrNoRows {
        return err
    }
    
    if currentVersion != expectedVersion {
        return fmt.Errorf("version conflict: expected %d, got %d", expectedVersion, currentVersion)
    }
    
    // ä¿å­˜äº‹ä»¶
    for _, event := range events {
        data, err := json.Marshal(event.GetData())
        if err != nil {
            return err
        }
        
        _, err = tx.ExecContext(ctx, `
            INSERT INTO events (aggregate_id, event_type, version, timestamp, data) 
            VALUES ($1, $2, $3, $4, $5)`,
            event.GetAggregateID(),
            event.GetEventType(),
            event.GetVersion(),
            event.GetTimestamp(),
            data,
        )
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}

func (es *PostgreSQLEventStore) LoadEvents(ctx context.Context, aggregateID string) ([]Event, error) {
    rows, err := es.db.QueryContext(ctx, `
        SELECT event_type, version, timestamp, data 
        FROM events 
        WHERE aggregate_id = $1 
        ORDER BY version`, aggregateID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var events []Event
    for rows.Next() {
        var event BaseEvent
        event.AggregateID = aggregateID
        
        err := rows.Scan(&event.EventType, &event.Version, &event.Timestamp, &event.Data)
        if err != nil {
            return nil, err
        }
        
        events = append(events, &event)
    }
    
    return events, nil
}

// èšåˆæ ¹åŸºç±»
type AggregateRoot struct {
    ID            string
    Version       int
    UncommittedEvents []Event
}

func (ar *AggregateRoot) GetUncommittedEvents() []Event {
    return ar.UncommittedEvents
}

func (ar *AggregateRoot) ClearUncommittedEvents() {
    ar.UncommittedEvents = nil
}

func (ar *AggregateRoot) ApplyEvent(event Event) {
    ar.UncommittedEvents = append(ar.UncommittedEvents, event)
    ar.Version++
}

// è®¢å•èšåˆæ ¹
type OrderAggregate struct {
    AggregateRoot
    UserID      string
    Items       []OrderItem
    Status      OrderStatus
    TotalAmount decimal.Decimal
    CreatedAt   time.Time
}

type OrderCreatedEvent struct {
    OrderID     string          `json:"order_id"`
    UserID      string          `json:"user_id"`
    Items       []OrderItem     `json:"items"`
    TotalAmount decimal.Decimal `json:"total_amount"`
    CreatedAt   time.Time       `json:"created_at"`
}

func (o *OrderAggregate) CreateOrder(userID string, items []OrderItem) error {
    if o.ID != "" {
        return errors.New("order already exists")
    }
    
    // è®¡ç®—æ€»é‡‘é¢
    totalAmount := decimal.Zero
    for _, item := range items {
        totalAmount = totalAmount.Add(item.Price.Mul(decimal.NewFromInt(int64(item.Quantity))))
    }
    
    // åˆ›å»ºäº‹ä»¶
    event := &OrderCreatedEvent{
        OrderID:     generateOrderID(),
        UserID:      userID,
        Items:       items,
        TotalAmount: totalAmount,
        CreatedAt:   time.Now(),
    }
    
    o.applyOrderCreated(event)
    o.ApplyEvent(&BaseEvent{
        AggregateID: o.ID,
        EventType:   "OrderCreated",
        Version:     o.Version + 1,
        Timestamp:   time.Now(),
        Data:        mustMarshal(event),
    })
    
    return nil
}

func (o *OrderAggregate) applyOrderCreated(event *OrderCreatedEvent) {
    o.ID = event.OrderID
    o.UserID = event.UserID
    o.Items = event.Items
    o.TotalAmount = event.TotalAmount
    o.Status = OrderStatusPending
    o.CreatedAt = event.CreatedAt
}

// ä»äº‹ä»¶é‡å»ºèšåˆ
func (o *OrderAggregate) LoadFromHistory(events []Event) {
    for _, event := range events {
        switch event.GetEventType() {
        case "OrderCreated":
            var orderCreated OrderCreatedEvent
            json.Unmarshal(event.(*BaseEvent).Data, &orderCreated)
            o.applyOrderCreated(&orderCreated)
        case "OrderConfirmed":
            o.Status = OrderStatusConfirmed
        case "OrderCancelled":
            o.Status = OrderStatusCancelled
        }
        o.Version = event.GetVersion()
    }
}
```

---

## æœåŠ¡é—´é€šä¿¡æ¨¡å¼

### ğŸ”„ **åŒæ­¥é€šä¿¡æ¨¡å¼**

#### gRPCæœåŠ¡å®ç°
```proto
// proto/user/user.proto
syntax = "proto3";

package user.v1;

option go_package = "github.com/company/ecommerce/proto/user/v1;userv1";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "validate/validate.proto";

service UserService {
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (google.protobuf.Empty);
  rpc ListUsers(ListUsersRequest) returns (ListUsersResponse);
  rpc AuthenticateUser(AuthenticateUserRequest) returns (AuthenticateUserResponse);
}

message User {
  string id = 1;
  string email = 2 [(validate.rules).string.email = true];
  string name = 3 [(validate.rules).string.min_len = 1];
  string phone = 4;
  repeated string roles = 5;
  UserStatus status = 6;
  google.protobuf.Timestamp created_at = 7;
  google.protobuf.Timestamp updated_at = 8;
}

enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0;
  USER_STATUS_ACTIVE = 1;
  USER_STATUS_INACTIVE = 2;
  USER_STATUS_SUSPENDED = 3;
}

message CreateUserRequest {
  string email = 1 [(validate.rules).string.email = true];
  string name = 2 [(validate.rules).string.min_len = 1];
  string password = 3 [(validate.rules).string.min_len = 8];
  string phone = 4;
  repeated string roles = 5;
}

message CreateUserResponse {
  User user = 1;
}

message GetUserRequest {
  string id = 1 [(validate.rules).string.min_len = 1];
}

message GetUserResponse {
  User user = 1;
}
```

```go
// internal/user/grpc_server.go
package user

import (
    "context"
    "log"
    
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    
    userv1 "github.com/company/ecommerce/proto/user/v1"
)

type GRPCServer struct {
    userv1.UnimplementedUserServiceServer
    service Service
}

func NewGRPCServer(service Service) *GRPCServer {
    return &GRPCServer{
        service: service,
    }
}

func (s *GRPCServer) CreateUser(ctx context.Context, req *userv1.CreateUserRequest) (*userv1.CreateUserResponse, error) {
    user := &User{
        Email:    req.Email,
        Name:     req.Name,
        Password: req.Password,
        Phone:    req.Phone,
        Roles:    req.Roles,
    }
    
    createdUser, err := s.service.CreateUser(ctx, user)
    if err != nil {
        log.Printf("Failed to create user: %v", err)
        return nil, status.Errorf(codes.Internal, "failed to create user: %v", err)
    }
    
    return &userv1.CreateUserResponse{
        User: s.toProtoUser(createdUser),
    }, nil
}

func (s *GRPCServer) GetUser(ctx context.Context, req *userv1.GetUserRequest) (*userv1.GetUserResponse, error) {
    user, err := s.service.GetUser(ctx, req.Id)
    if err != nil {
        if err == ErrUserNotFound {
            return nil, status.Errorf(codes.NotFound, "user not found")
        }
        log.Printf("Failed to get user: %v", err)
        return nil, status.Errorf(codes.Internal, "failed to get user: %v", err)
    }
    
    return &userv1.GetUserResponse{
        User: s.toProtoUser(user),
    }, nil
}

func (s *GRPCServer) toProtoUser(user *User) *userv1.User {
    return &userv1.User{
        Id:        user.ID,
        Email:     user.Email,
        Name:      user.Name,
        Phone:     user.Phone,
        Roles:     user.Roles,
        Status:    userv1.UserStatus(user.Status),
        CreatedAt: timestamppb.New(user.CreatedAt),
        UpdatedAt: timestamppb.New(user.UpdatedAt),
    }
}

// gRPCå®¢æˆ·ç«¯å°è£…
type GRPCClient struct {
    conn   *grpc.ClientConn
    client userv1.UserServiceClient
}

func NewGRPCClient(target string) (*GRPCClient, error) {
    conn, err := grpc.Dial(target, 
        grpc.WithTransportCredentials(insecure.NewCredentials()),
        grpc.WithUnaryInterceptor(grpc_retry.UnaryClientInterceptor(
            grpc_retry.WithCodes(codes.Unavailable, codes.DeadlineExceeded),
            grpc_retry.WithMax(3),
            grpc_retry.WithBackoff(grpc_retry.BackoffExponential(100*time.Millisecond)),
        )),
    )
    if err != nil {
        return nil, err
    }
    
    client := userv1.NewUserServiceClient(conn)
    
    return &GRPCClient{
        conn:   conn,
        client: client,
    }, nil
}

func (c *GRPCClient) CreateUser(ctx context.Context, user *User) (*User, error) {
    req := &userv1.CreateUserRequest{
        Email:    user.Email,
        Name:     user.Name,
        Password: user.Password,
        Phone:    user.Phone,
        Roles:    user.Roles,
    }
    
    resp, err := c.client.CreateUser(ctx, req)
    if err != nil {
        return nil, err
    }
    
    return c.fromProtoUser(resp.User), nil
}

func (c *GRPCClient) fromProtoUser(protoUser *userv1.User) *User {
    return &User{
        ID:        protoUser.Id,
        Email:     protoUser.Email,
        Name:      protoUser.Name,
        Phone:     protoUser.Phone,
        Roles:     protoUser.Roles,
        Status:    UserStatus(protoUser.Status),
        CreatedAt: protoUser.CreatedAt.AsTime(),
        UpdatedAt: protoUser.UpdatedAt.AsTime(),
    }
}

func (c *GRPCClient) Close() error {
    return c.conn.Close()
}
```

### ğŸ“¨ **å¼‚æ­¥é€šä¿¡æ¨¡å¼**

#### åŸºäºKafkaçš„äº‹ä»¶é©±åŠ¨æ¶æ„
```go
// äº‹ä»¶å‘å¸ƒå™¨
package events

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    
    "github.com/Shopify/sarama"
)

type EventPublisher interface {
    Publish(ctx context.Context, topic string, event interface{}) error
    PublishBatch(ctx context.Context, events []EventMessage) error
    Close() error
}

type EventMessage struct {
    Topic string
    Key   string
    Event interface{}
}

type KafkaEventPublisher struct {
    producer sarama.SyncProducer
}

func NewKafkaEventPublisher(brokers []string) (*KafkaEventPublisher, error) {
    config := sarama.NewConfig()
    config.Producer.RequiredAcks = sarama.WaitForAll
    config.Producer.Retry.Max = 5
    config.Producer.Return.Successes = true
    config.Producer.Compression = sarama.CompressionSnappy
    
    producer, err := sarama.NewSyncProducer(brokers, config)
    if err != nil {
        return nil, err
    }
    
    return &KafkaEventPublisher{
        producer: producer,
    }, nil
}

func (p *KafkaEventPublisher) Publish(ctx context.Context, topic string, event interface{}) error {
    data, err := json.Marshal(event)
    if err != nil {
        return fmt.Errorf("failed to marshal event: %w", err)
    }
    
    msg := &sarama.ProducerMessage{
        Topic: topic,
        Value: sarama.StringEncoder(data),
    }
    
    // å¦‚æœäº‹ä»¶æœ‰IDï¼Œä½¿ç”¨ä½œä¸ºåˆ†åŒºé”®
    if eventWithID, ok := event.(interface{ GetID() string }); ok {
        msg.Key = sarama.StringEncoder(eventWithID.GetID())
    }
    
    partition, offset, err := p.producer.SendMessage(msg)
    if err != nil {
        return fmt.Errorf("failed to send message: %w", err)
    }
    
    log.Printf("Message sent to partition %d at offset %d", partition, offset)
    return nil
}

func (p *KafkaEventPublisher) PublishBatch(ctx context.Context, events []EventMessage) error {
    messages := make([]*sarama.ProducerMessage, 0, len(events))
    
    for _, eventMsg := range events {
        data, err := json.Marshal(eventMsg.Event)
        if err != nil {
            return fmt.Errorf("failed to marshal event: %w", err)
        }
        
        msg := &sarama.ProducerMessage{
            Topic: eventMsg.Topic,
            Key:   sarama.StringEncoder(eventMsg.Key),
            Value: sarama.StringEncoder(data),
        }
        
        messages = append(messages, msg)
    }
    
    return p.producer.SendMessages(messages)
}

func (p *KafkaEventPublisher) Close() error {
    return p.producer.Close()
}

// äº‹ä»¶æ¶ˆè´¹å™¨
type EventConsumer interface {
    Subscribe(topics []string, handler EventHandler) error
    Close() error
}

type EventHandler func(ctx context.Context, message *EventMessage) error

type KafkaEventConsumer struct {
    consumer      sarama.ConsumerGroup
    groupID       string
    eventHandlers map[string]EventHandler
    ctx           context.Context
    cancel        context.CancelFunc
}

func NewKafkaEventConsumer(brokers []string, groupID string) (*KafkaEventConsumer, error) {
    config := sarama.NewConfig()
    config.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRoundRobin
    config.Consumer.Offsets.Initial = sarama.OffsetOldest
    config.Consumer.Group.Session.Timeout = 10 * time.Second
    config.Consumer.Group.Heartbeat.Interval = 3 * time.Second
    
    consumer, err := sarama.NewConsumerGroup(brokers, groupID, config)
    if err != nil {
        return nil, err
    }
    
    ctx, cancel := context.WithCancel(context.Background())
    
    return &KafkaEventConsumer{
        consumer:      consumer,
        groupID:       groupID,
        eventHandlers: make(map[string]EventHandler),
        ctx:           ctx,
        cancel:        cancel,
    }, nil
}

func (c *KafkaEventConsumer) Subscribe(topics []string, handler EventHandler) error {
    consumerGroupHandler := &ConsumerGroupHandler{
        eventHandler: handler,
    }
    
    go func() {
        for {
            select {
            case <-c.ctx.Done():
                return
            default:
                if err := c.consumer.Consume(c.ctx, topics, consumerGroupHandler); err != nil {
                    log.Printf("Error consuming messages: %v", err)
                }
            }
        }
    }()
    
    return nil
}

func (c *KafkaEventConsumer) Close() error {
    c.cancel()
    return c.consumer.Close()
}

type ConsumerGroupHandler struct {
    eventHandler EventHandler
}

func (h *ConsumerGroupHandler) Setup(sarama.ConsumerGroupSession) error   { return nil }
func (h *ConsumerGroupHandler) Cleanup(sarama.ConsumerGroupSession) error { return nil }

func (h *ConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
    for message := range claim.Messages() {
        eventMsg := &EventMessage{
            Topic: message.Topic,
            Key:   string(message.Key),
        }
        
        // ååºåˆ—åŒ–äº‹ä»¶æ•°æ®
        if err := json.Unmarshal(message.Value, &eventMsg.Event); err != nil {
            log.Printf("Failed to unmarshal event: %v", err)
            continue
        }
        
        // å¤„ç†äº‹ä»¶
        if err := h.eventHandler(session.Context(), eventMsg); err != nil {
            log.Printf("Failed to handle event: %v", err)
            continue
        }
        
        // æ ‡è®°æ¶ˆæ¯å·²å¤„ç†
        session.MarkMessage(message, "")
    }
    
    return nil
}
```

---

## å¾®æœåŠ¡æ²»ç†

### ğŸ›¡ï¸ **å®¹é”™å’Œç¨³å®šæ€§**

#### ç†”æ–­å™¨æ¨¡å¼å®ç°
```go
// ç†”æ–­å™¨å®ç°
package circuitbreaker

import (
    "context"
    "errors"
    "sync"
    "time"
)

type State int

const (
    StateClosed State = iota
    StateHalfOpen
    StateOpen
)

type CircuitBreaker struct {
    mutex           sync.RWMutex
    state           State
    failureCount    int64
    successCount    int64
    lastFailureTime time.Time
    lastSuccessTime time.Time
    
    // é…ç½®
    failureThreshold int64
    successThreshold int64
    timeout          time.Duration
    maxRequests      int64
}

type Config struct {
    FailureThreshold int64         // å¤±è´¥é˜ˆå€¼
    SuccessThreshold int64         // æˆåŠŸé˜ˆå€¼ (åŠå¼€çŠ¶æ€)
    Timeout          time.Duration // è¶…æ—¶æ—¶é—´
    MaxRequests      int64         // åŠå¼€çŠ¶æ€æœ€å¤§è¯·æ±‚æ•°
}

func NewCircuitBreaker(config Config) *CircuitBreaker {
    return &CircuitBreaker{
        state:            StateClosed,
        failureThreshold: config.FailureThreshold,
        successThreshold: config.SuccessThreshold,
        timeout:          config.Timeout,
        maxRequests:      config.MaxRequests,
    }
}

func (cb *CircuitBreaker) Execute(fn func() (interface{}, error)) (interface{}, error) {
    if !cb.allow() {
        return nil, errors.New("circuit breaker is open")
    }
    
    result, err := fn()
    
    if err != nil {
        cb.onFailure()
        return nil, err
    }
    
    cb.onSuccess()
    return result, nil
}

func (cb *CircuitBreaker) allow() bool {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    switch cb.state {
    case StateClosed:
        return true
    case StateOpen:
        if time.Since(cb.lastFailureTime) > cb.timeout {
            cb.state = StateHalfOpen
            cb.failureCount = 0
            cb.successCount = 0
            return true
        }
        return false
    case StateHalfOpen:
        return cb.successCount+cb.failureCount < cb.maxRequests
    default:
        return false
    }
}

func (cb *CircuitBreaker) onSuccess() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    cb.successCount++
    cb.lastSuccessTime = time.Now()
    
    if cb.state == StateHalfOpen && cb.successCount >= cb.successThreshold {
        cb.state = StateClosed
        cb.failureCount = 0
        cb.successCount = 0
    }
}

func (cb *CircuitBreaker) onFailure() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    cb.failureCount++
    cb.lastFailureTime = time.Now()
    
    if cb.state == StateClosed && cb.failureCount >= cb.failureThreshold {
        cb.state = StateOpen
    } else if cb.state == StateHalfOpen {
        cb.state = StateOpen
    }
}

func (cb *CircuitBreaker) GetState() State {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    return cb.state
}

// gRPCæ‹¦æˆªå™¨é›†æˆç†”æ–­å™¨
func CircuitBreakerUnaryInterceptor(cb *CircuitBreaker) grpc.UnaryClientInterceptor {
    return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
        _, err := cb.Execute(func() (interface{}, error) {
            return nil, invoker(ctx, method, req, reply, cc, opts...)
        })
        return err
    }
}

// HTTPå®¢æˆ·ç«¯é›†æˆç†”æ–­å™¨
type CircuitBreakerHTTPClient struct {
    client *http.Client
    cb     *CircuitBreaker
}

func NewCircuitBreakerHTTPClient(client *http.Client, cb *CircuitBreaker) *CircuitBreakerHTTPClient {
    return &CircuitBreakerHTTPClient{
        client: client,
        cb:     cb,
    }
}

func (c *CircuitBreakerHTTPClient) Do(req *http.Request) (*http.Response, error) {
    result, err := c.cb.Execute(func() (interface{}, error) {
        return c.client.Do(req)
    })
    
    if err != nil {
        return nil, err
    }
    
    return result.(*http.Response), nil
}
```

#### é™æµå™¨å®ç°
```go
// ä»¤ç‰Œæ¡¶é™æµå™¨
package ratelimiter

import (
    "context"
    "sync"
    "time"
    
    "golang.org/x/time/rate"
)

type RateLimiter interface {
    Allow() bool
    Wait(ctx context.Context) error
    Reserve() *Reservation
}

// ä»¤ç‰Œæ¡¶é™æµå™¨
type TokenBucketRateLimiter struct {
    limiter *rate.Limiter
}

func NewTokenBucketRateLimiter(r rate.Limit, b int) *TokenBucketRateLimiter {
    return &TokenBucketRateLimiter{
        limiter: rate.NewLimiter(r, b),
    }
}

func (t *TokenBucketRateLimiter) Allow() bool {
    return t.limiter.Allow()
}

func (t *TokenBucketRateLimiter) Wait(ctx context.Context) error {
    return t.limiter.Wait(ctx)
}

func (t *TokenBucketRateLimiter) Reserve() *Reservation {
    reservation := t.limiter.Reserve()
    return &Reservation{reservation: reservation}
}

type Reservation struct {
    reservation *rate.Reservation
}

func (r *Reservation) OK() bool {
    return r.reservation.OK()
}

func (r *Reservation) Delay() time.Duration {
    return r.reservation.Delay()
}

func (r *Reservation) Cancel() {
    r.reservation.Cancel()
}

// æ»‘åŠ¨çª—å£é™æµå™¨
type SlidingWindowRateLimiter struct {
    mutex     sync.RWMutex
    requests  []time.Time
    limit     int
    window    time.Duration
    lastClean time.Time
}

func NewSlidingWindowRateLimiter(limit int, window time.Duration) *SlidingWindowRateLimiter {
    return &SlidingWindowRateLimiter{
        requests:  make([]time.Time, 0, limit),
        limit:     limit,
        window:    window,
        lastClean: time.Now(),
    }
}

func (s *SlidingWindowRateLimiter) Allow() bool {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    now := time.Now()
    s.cleanOldRequests(now)
    
    if len(s.requests) >= s.limit {
        return false
    }
    
    s.requests = append(s.requests, now)
    return true
}

func (s *SlidingWindowRateLimiter) cleanOldRequests(now time.Time) {
    // é¿å…é¢‘ç¹æ¸…ç†
    if now.Sub(s.lastClean) < s.window/10 {
        return
    }
    
    cutoff := now.Add(-s.window)
    validIndex := 0
    
    for i, requestTime := range s.requests {
        if requestTime.After(cutoff) {
            validIndex = i
            break
        }
    }
    
    if validIndex > 0 {
        copy(s.requests, s.requests[validIndex:])
        s.requests = s.requests[:len(s.requests)-validIndex]
    }
    
    s.lastClean = now
}

// åˆ†å¸ƒå¼é™æµå™¨ (åŸºäºRedis)
type DistributedRateLimiter struct {
    redis  RedisClient
    script string
}

func NewDistributedRateLimiter(redis RedisClient) *DistributedRateLimiter {
    script := `
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])
        local current_time = tonumber(ARGV[3])
        
        -- æ¸…ç†è¿‡æœŸçš„è¯·æ±‚
        redis.call('ZREMRANGEBYSCORE', key, '-inf', current_time - window)
        
        -- è·å–å½“å‰è®¡æ•°
        local current_count = redis.call('ZCARD', key)
        
        if current_count < limit then
            -- æ·»åŠ å½“å‰è¯·æ±‚
            redis.call('ZADD', key, current_time, current_time)
            redis.call('EXPIRE', key, window)
            return {1, limit - current_count - 1}
        else
            return {0, 0}
        end
    `
    
    return &DistributedRateLimiter{
        redis:  redis,
        script: script,
    }
}

func (d *DistributedRateLimiter) Allow(ctx context.Context, key string, limit int, window time.Duration) (bool, error) {
    now := time.Now().Unix()
    windowSeconds := int(window.Seconds())
    
    result, err := d.redis.Eval(ctx, d.script, []string{key}, limit, windowSeconds, now).Result()
    if err != nil {
        return false, err
    }
    
    values := result.([]interface{})
    allowed := values[0].(int64) == 1
    
    return allowed, nil
}
```

### ğŸ“Š **æœåŠ¡ç›‘æ§å’Œè§‚æµ‹**

#### åˆ†å¸ƒå¼è¿½è¸ªå®ç°
```go
// OpenTelemetryé›†æˆ
package tracing

import (
    "context"
    "log"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/resource"
    "go.opentelemetry.io/otel/sdk/trace"
    semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
    "go.opentelemetry.io/otel/trace"
)

func InitTracer(serviceName, jaegerEndpoint string) func() {
    exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(jaegerEndpoint)))
    if err != nil {
        log.Fatal(err)
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exp),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceName(serviceName),
            semconv.ServiceVersion("1.0.0"),
            attribute.String("environment", "production"),
        )),
        trace.WithSampler(trace.TraceIDRatioBased(0.1)), // 10% é‡‡æ ·ç‡
    )
    
    otel.SetTracerProvider(tp)
    
    return func() {
        if err := tp.Shutdown(context.Background()); err != nil {
            log.Fatal(err)
        }
    }
}

// æœåŠ¡é—´è°ƒç”¨è¿½è¸ª
func TraceServiceCall(ctx context.Context, serviceName, operation string, fn func(context.Context) error) error {
    tracer := otel.Tracer("microservice-tracer")
    
    ctx, span := tracer.Start(ctx, fmt.Sprintf("%s.%s", serviceName, operation))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("service.name", serviceName),
        attribute.String("operation.name", operation),
    )
    
    err := fn(ctx)
    if err != nil {
        span.SetStatus(codes.Error, err.Error())
        span.RecordError(err)
    } else {
        span.SetStatus(codes.Ok, "success")
    }
    
    return err
}

// æ•°æ®åº“æŸ¥è¯¢è¿½è¸ª
func TraceDatabaseQuery(ctx context.Context, query string, args []interface{}, fn func() error) error {
    tracer := otel.Tracer("database-tracer")
    
    ctx, span := tracer.Start(ctx, "database.query")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("db.system", "postgresql"),
        attribute.String("db.statement", query),
        attribute.Int("db.args.count", len(args)),
    )
    
    start := time.Now()
    err := fn()
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Float64("db.duration.ms", float64(duration.Nanoseconds())/1e6),
    )
    
    if err != nil {
        span.SetStatus(codes.Error, err.Error())
        span.RecordError(err)
    } else {
        span.SetStatus(codes.Ok, "success")
    }
    
    return err
}

// HTTPå®¢æˆ·ç«¯è¿½è¸ª
type TracingHTTPClient struct {
    client *http.Client
    tracer trace.Tracer
}

func NewTracingHTTPClient(client *http.Client) *TracingHTTPClient {
    return &TracingHTTPClient{
        client: client,
        tracer: otel.Tracer("http-client"),
    }
}

func (c *TracingHTTPClient) Do(req *http.Request) (*http.Response, error) {
    ctx, span := c.tracer.Start(req.Context(), fmt.Sprintf("HTTP %s", req.Method))
    defer span.End()
    
    span.SetAttributes(
        attribute.String("http.method", req.Method),
        attribute.String("http.url", req.URL.String()),
        attribute.String("http.scheme", req.URL.Scheme),
        attribute.String("http.host", req.URL.Host),
        attribute.String("http.target", req.URL.Path),
    )
    
    // æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡åˆ°è¯·æ±‚å¤´
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))
    
    start := time.Now()
    resp, err := c.client.Do(req.WithContext(ctx))
    duration := time.Since(start)
    
    span.SetAttributes(
        attribute.Float64("http.duration.ms", float64(duration.Nanoseconds())/1e6),
    )
    
    if err != nil {
        span.SetStatus(codes.Error, err.Error())
        span.RecordError(err)
        return nil, err
    }
    
    span.SetAttributes(
        attribute.Int("http.status_code", resp.StatusCode),
        attribute.String("http.status_text", resp.Status),
    )
    
    if resp.StatusCode >= 400 {
        span.SetStatus(codes.Error, fmt.Sprintf("HTTP %d", resp.StatusCode))
    } else {
        span.SetStatus(codes.Ok, "success")
    }
    
    return resp, nil
}
```

---

## å®æˆ˜é¡¹ç›®å®æ–½

### ğŸš€ **ç”µå•†å¾®æœåŠ¡å¹³å°**

#### é¡¹ç›®æ¶æ„å›¾
```
                                Frontend Applications
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚   Web App   â”‚ Mobile App  â”‚ Admin Panel â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚              API Gateway               â”‚
                           â”‚         (Kong / Custom)                â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                                 â”‚                                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚ User Services â”‚              â”‚ Product Services   â”‚              â”‚ Order Services â”‚
    â”‚               â”‚              â”‚                    â”‚              â”‚                â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚              â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚              â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚User Svc   â”‚ â”‚              â”‚ â”‚Product Svc     â”‚ â”‚              â”‚ â”‚Order Svc   â”‚ â”‚
    â”‚ â”‚Auth Svc   â”‚ â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚Inventory Svc   â”‚ â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚Cart Svc    â”‚ â”‚
    â”‚ â”‚Profile Svcâ”‚ â”‚              â”‚ â”‚Category Svc    â”‚ â”‚              â”‚ â”‚Payment Svc â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚              â”‚ â”‚Search Svc      â”‚ â”‚              â”‚ â”‚Shipping Svcâ”‚ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
            â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                â”‚                                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚   User DB    â”‚              â”‚   Product DB       â”‚              â”‚   Order DB    â”‚
    â”‚ (PostgreSQL) â”‚              â”‚ (PostgreSQL)       â”‚              â”‚ (PostgreSQL)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ + Redis Cache      â”‚              â”‚ + Redis       â”‚
                                  â”‚ + Elasticsearch    â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚              Message Bus               â”‚
                           â”‚              (Apache Kafka)            â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚           Shared Services              â”‚
                           â”‚                                        â”‚
                           â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                           â”‚ â”‚Notification â”‚ Analytics   â”‚ Audit   â”‚ â”‚
                           â”‚ â”‚   Service   â”‚  Service    â”‚Service  â”‚ â”‚
                           â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®Œæ•´éƒ¨ç½²é…ç½®
```yaml
# namespaceå®šä¹‰
apiVersion: v1
kind: Namespace
metadata:
  name: ecommerce
  labels:
    name: ecommerce
    istio-injection: enabled
---
# ç”¨æˆ·æœåŠ¡éƒ¨ç½²
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: ecommerce
  labels:
    app: user-service
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
      version: v1
  template:
    metadata:
      labels:
        app: user-service
        version: v1
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: user-service
      containers:
      - name: user-service
        image: ecommerce/user-service:v1.2.0
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 9090
          name: grpc
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: user-db-secret
              key: url
        - name: REDIS_URL
          value: "redis://redis-cluster:6379"
        - name: KAFKA_BROKERS
          value: "kafka-0:9092,kafka-1:9092,kafka-2:9092"
        - name: JAEGER_ENDPOINT
          value: "http://jaeger-collector:14268/api/traces"
        - name: SERVICE_NAME
          value: "user-service"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"  
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
      volumes:
      - name: config
        configMap:
          name: user-service-config
---
# ç”¨æˆ·æœåŠ¡Service
apiVersion: v1
kind: Service
metadata:
  name: user-service
  namespace: ecommerce
  labels:
    app: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 8080
    targetPort: 8080
    name: http
  - port: 9090
    targetPort: 9090
    name: grpc
---
# ç”¨æˆ·æœåŠ¡é…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-service-config
  namespace: ecommerce
data:
  config.yaml: |
    server:
      http_port: 8080
      grpc_port: 9090
      shutdown_timeout: 30s
    
    database:
      max_open_conns: 25
      max_idle_conns: 5
      conn_max_lifetime: 5m
    
    cache:
      ttl: 5m
      max_entries: 10000
    
    auth:
      jwt_secret: ${JWT_SECRET}
      token_expiry: 24h
    
    rate_limiting:
      requests_per_second: 100
      burst: 200
    
    circuit_breaker:
      failure_threshold: 5
      success_threshold: 3
      timeout: 60s
---
# Istio VirtualService
apiVersion: networking.istio.io/v1beta1
kind: VirtualService  
metadata:
  name: user-service
  namespace: ecommerce
spec:
  hosts:
  - user-service
  http:
  - match:
    - uri:
        prefix: /api/v1/users
    route:
    - destination:
        host: user-service
        port:
          number: 8080
    timeout: 30s
    retries:
      attempts: 3
      perTryTimeout: 10s
      retryOn: gateway-error,connect-failure,refused-stream
---
# Istio DestinationRule
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: user-service
  namespace: ecommerce
spec:
  host: user-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 100
        maxRequestsPerConnection: 10
    circuitBreaker:
      consecutiveErrors: 3
      intervalSeconds: 30
      baseEjectionTimeSeconds: 30
      maxEjectionPercent: 50
    loadBalancer:
      simple: LEAST_CONN
  subsets:
  - name: v1
    labels:
      version: v1
---
# HPAè‡ªåŠ¨æ‰©ç¼©å®¹
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: user-service-hpa
  namespace: ecommerce
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: user-service
  minReplicas: 3
  maxReplicas: 20  
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
      - type: Pods
        value: 4
        periodSeconds: 15
      selectPolicy: Max
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
```

### âœ… **éªŒæ”¶æ ‡å‡†**

å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

**å¾®æœåŠ¡è®¾è®¡èƒ½åŠ›**:
- [ ] æ ¹æ®ä¸šåŠ¡é¢†åŸŸåˆç†æ‹†åˆ†å¾®æœåŠ¡
- [ ] è®¾è®¡æ¾è€¦åˆã€é«˜å†…èšçš„æœåŠ¡è¾¹ç•Œ
- [ ] å®ç°æœ‰æ•ˆçš„æœåŠ¡é—´é€šä¿¡æœºåˆ¶
- [ ] å¤„ç†åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ•°æ®ä¸€è‡´æ€§é—®é¢˜

**æ¶æ„å®ç°èƒ½åŠ›**:
- [ ] é…ç½®å’Œç®¡ç†APIç½‘å…³
- [ ] å®ç°æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡
- [ ] å»ºç«‹äº‹ä»¶é©±åŠ¨æ¶æ„
- [ ] å®æ–½Sagaæ¨¡å¼å’Œäº‹ä»¶æº¯æº

**æ²»ç†å’Œè¿ç»´èƒ½åŠ›**:
- [ ] å®ç°ç†”æ–­ã€é™æµã€é‡è¯•æœºåˆ¶
- [ ] å»ºç«‹åˆ†å¸ƒå¼è¿½è¸ªä½“ç³»
- [ ] é…ç½®æœåŠ¡ç›‘æ§å’Œå‘Šè­¦
- [ ] è¿›è¡Œå¾®æœåŠ¡éƒ¨ç½²å’Œæ‰©ç¼©å®¹

**é¡¹ç›®äº¤ä»˜èƒ½åŠ›**:
- [ ] å®Œæˆå®Œæ•´çš„å¾®æœåŠ¡ç”µå•†å¹³å°
- [ ] å®ç°æœåŠ¡çš„è‡ªåŠ¨åŒ–éƒ¨ç½²
- [ ] å»ºç«‹æœåŠ¡è´¨é‡ç›‘æ§ä½“ç³»
- [ ] å…·å¤‡å¤æ‚é—®é¢˜çš„æ•…éšœæ’æŸ¥èƒ½åŠ›

---

*ä¸‹ä¸€ç« : [äº‘åŸç”ŸæŠ€æœ¯æ ˆ](./äº‘åŸç”ŸæŠ€æœ¯æ ˆ.md)*